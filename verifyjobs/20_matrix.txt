MATRIX,T0.
COMMENT. TEST PASCAL 6000 AND MNF COMPILERS
RFL,120000.
REDUCE.
PASCAL.
LGO.
M77,BL,GO=0.
LOAD,LGO.
LDSET,LIB=SYMLIB.
EXECUTE.
COMMENT. *** MATRIX COMPLETE ***
EXIT(S)
COMMENT. *** MATRIX FAILED ***
~eor
(*$S-*)
(*$W20000*)
PROGRAM MATCOMP(INPUT,OUTPUT,LOGO);

(* 
 
  PROGRAM MATCOMP

  THIS PRORAM IS A COMPILER AND RUNTIME FOR A SIMPLE LANGUAGE TO
  DO COMPUTATIONS IN LINEAR ALGEBRA.

  THE MATCOMP COMPILER WAS HEAVILY INFLUENCED BY NIKLAS WIRTHS BOOK
  "COMPILERBAU".

  THE SOURCE PROGRAM IS COMPILED INTO AN INTERMEDIATE CODE FILE (LOGO).

  LOGO AND INPUT DATA ARE PROCESSED BY THE FORTRAN PROGRAM MATEXE.

  AUTHOR:   JOACHIM SIEBOLD


  DEVELOPMENT HISTORY

  DATE        PROGRAMMER     MODIFICATION
  --------    ----------     ------------
  04.06.86    J. SIEBOLD     CODED AND DOCUMENTED

  THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR
  MODIFY IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE
  AS PUBLISHED BY THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2
  OF THE LICENSE, OR (AT YOUR OPTION) ANY LATER VERSION.

  THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
  BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
  MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
  GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.

  YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
  ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
  FOUNDATION, INC., 59 TEMPLE PLACE - SUITE 330, BOSTON, MA  02111-1307, USA.

*)

CONST NORW = 14;       (* NO. OF RESERVED WORDS *)
 NORF =  14;           (* NO. OF FUNCTIONS *)
 NMAX =  7;            (* MAX. NO OF DIGITS IN NUMBER *) (* LONG *)
 AL = 20;              (* LENGTH OF IDENTIFIERS *)
 CHSETSIZE = 64;       (* LENGTH OF CHARACTER SET *)
 MAXERR = 30;          (* MAX. NUMBER OF ERRORS *)
 LINELENGTH= 81;       (* LENGTH OF INPUT LINE + 1 *)
 MAXNUM = 9999999;     (* MAX. NUMBER IN CONSTANT EXPRESSION *) (* LONG *)
 FORMLEN = 62;         (* LENGTH OF FORMULAR *)
 FORMWIDTH= 80;        (* WIDTH OF FORMULAR *)
 LZ= ' ';              (* LEFT MARGIN OF COMPILER OUTPUT *)
 MAXERRNO= 50;         (* MAX NO OF ERROR MESSAGES *)
 TEMPSTRING=  '$TEMPMAT            ';

TYPE SYMBOL =
  (NUL,IDENT,NUMBER,PLUS,MINUS,TIMES,SLASH,SHARP,APOSTROPH,
  EQL,LPAREN,RPAREN,COMMA,SEMICOLON,TWOPOINT,LBRACKET,RBRACKET,
  PERIOD,BECOMES,ENDSYM,PROGRAMSYM,CONSTSYM,READSYM,PRINTSYM,
  WRITESYM,SYMSYM,DIAGSYM,TRANSSYM,ZERSYM,IDNSYM,
  CONSYM,CREATESYM,CALLSYM,ENDF);
  XALFA = PACKED ARRAY[1..AL] OF CHAR;
  SYMSET = SET OF SYMBOL;
  MEMTYPE= (MAIN,TEMP,SCRATCH);
  LREF= ^LINEREF;
  LINEREF = RECORD
             LINENO: INTEGER;
             NEXTREF: LREF;
            END;
  REF = ^ENTRYTYPE;
  CONSTMAT= (MATRIX,CONSTANT);
  ENTRYTYPE = RECORD
               NAME : XALFA;
               INVALID: BOOLEAN;
               LEFT,
               RIGHT: REF;
               FIRSTREF: LREF;
               LASTREF: LREF;
               CASE KIND: CONSTMAT OF
               CONSTANT: (VAL: INTEGER);
               MATRIX  : (L,R: INTEGER;
                          XADR:INTEGER)
            END;
  TRTYPE  =  (ONE,LN,RW);
  FNCTYPE  = RECORD
               FNAME: XALFA;
               TRCODE: ARRAY[1..4] OF TRTYPE;
               TMPSIZE:ARRAY[1..4] OF INTEGER;
               FCODE: INTEGER;
            END;
  CODETYPE= (CODE,CHARS);
  CODEREF = ^CODELINE;
  CODELINE = RECORD
              NEXTCODE: CODEREF;
              CASE CODEKIND: CODETYPE OF
              CODE: (CDXADR: INTEGER;
                     CDL,CDR,CDL1,CDL2,CDR1,CDR2: INTEGER);
              CHARS:(CODETEXT: XALFA)
              END;
  SFILLTYP= (BFILL, ZFILL);


VAR CH : CHAR;         (* LAST CHARACTER READ *)
  SYM : SYMBOL;        (* LAST SYMBOL READ *)
  ID : XALFA;           (* LAST IDENTIFIER READ *)
  NUM: INTEGER;        (* LAST NUMBER READ *)
  CC: INTEGER;         (* CHARACTER COUNT *)
  LL: INTEGER;         (* LINE LENGTH *)
  PROGNAME: XALFA;      (* PROGRAM NAME *)
  ERRFLAG: BOOLEAN;    (* ERROR FLAG *)
  SLINENR: INTEGER;    (* SOURCE LINE NUMBER *)
  LLINENR: INTEGER;    (* LISTING LINE NUMBER *)
  MATRIXENTERED: BOOLEAN; (* FLAG INDICATING THAT MATRIX IS IN SYMBOLTABLE *)
  CONSTANTENTERED: BOOLEAN; (* FLAG INDICATING THAT CONST IS IN SYMBOLTABLE *)
  TEXTLEN: INTEGER; (* LENGTH OF PRINT BUFFER *)
  PAGENO: INTEGER;  (* PAGE NUMBER *)
  ERRORS: PACKED ARRAY[1..MAXERRNO] OF BOOLEAN;
  KK,ERR: INTEGER;
  LINE: PACKED ARRAY[1..LINELENGTH] OF CHAR;
  A: XALFA;
  TEXTBUF: PACKED ARRAY[1..LINELENGTH] OF CHAR;
  LOGO: TEXT;
  TOKEN: ARRAY[1..NORW] OF XALFA;
  WSYM: ARRAY[1..NORW] OF SYMBOL;
  FUNCT:ARRAY[1..NORF] OF FNCTYPE;
  SSYM: ARRAY[CHAR] OF SYMBOL;
  STATBEGSYS, FACBEGSYS: SYMSET;
  MAXMEM,MAINEND,SCRATCHEND,TEMPEND: INTEGER;
  ROOT: REF;
  FIRSTCODE,LASTCODE: CODEREF;
  TIMEVAR: ALFA;
  DATEVAR: ALFA;
  MATRIXVERSION: PACKED ARRAY[1..30] OF CHAR;


(* MATDEPEND.INC*)
(* ********** MASCHINENABHAENGIGE ROUTINEN ************ *)

PROCEDURE EJECT;
(* ZWECK: AUF DER STANDARDAUSGABEDATEI WIRD EIN DRUCKSEITENVORSCHUB
         DURCHGEFUEHRT *)
BEGIN
   WRITELN(OUTPUT,'1');
END;

PROCEDURE GETTIMEDATE;

BEGIN
   TIME(TIMEVAR);
   DATE(DATEVAR);
END;               

PROCEDURE INITFILES;
(* ZWECK: DIE  DATEIEN     INPUT
                          OUTPUT
                          WERDEN MIT DEN EXTERNEN DATEINAMEN VERKNUEPFT *)
BEGIN
   GETTIMEDATE;
   MATRIXVERSION:='MATRIX COMPILER 2.0 (CDC NOS) ';
   RESET(INPUT);
   REWRITE(OUTPUT);
   REWRITE(LOGO);
END;

PROCEDURE CLOSEFILES;
(* ZWECK: DIE DATEIEN    STANDARDEINGABE (INPUT)
                        STANDARDAUSGABE (OUTPUT)
                        LOGO
                        WERDEN GESCHLOSSEN

  WENN EIN FEHLER AUFGETRETEN IST, WIRD LOGO GELOESCHT *)
BEGIN
   IF ERR <> 0 THEN BEGIN
      REWRITE(LOGO);
   END;
END;

PROCEDURE TERMINATE;
(* ZWECK:  PROGRAMM ABBRECHEN UND EINE INFORMATION AN DAS
          BETRIEBSSYSTEM UEBERGEBEN, DASS EIN BATCH- JOB
          ABGEBROCHEN WIRD *)

BEGIN
   HALT;
END;

FUNCTION EOL(VAR F:TEXT):BOOLEAN;
(* PORTABLE EOLN FUNKTION:
  WENN EOL TRUE IST, STEHT DER READ POINTER AUF DEM ERSTEN
  ZEICHEN DER NAECHSTEN ZEILE *)


BEGIN
   IF EOLN(F) THEN BEGIN
      READLN(F);
      EOL:=TRUE;
   END
   ELSE EOL:= FALSE;
END;

(* ********* ENDE MASCHINENABHAENGIGE ROUTINEN ********* *)

(* MATIO.INC*)
PROCEDURE NEWPAGE;
VAR SP: INTEGER;

BEGIN
   SP:= FORMWIDTH-65;
   EJECT;
   WRITELN(OUTPUT);
   PAGENO:= PAGENO+1;
   WRITE(OUTPUT,LZ,MATRIXVERSION,' ':SP,DATEVAR);
   WRITE(OUTPUT,' ':4,TIMEVAR);
   WRITELN(OUTPUT,' ':2,'PAGE ',PAGENO:2);
   WRITELN(OUTPUT,LZ,'(C) COPYRIGHT  J. SIEBOLD  1985, 1986, 1987, 1988');
   WRITELN(OUTPUT);
   LLINENR:=5
END;

PROCEDURE ADV(L1,L2: INTEGER);
BEGIN
   IF LLINENR+L2 > FORMLEN THEN NEWPAGE
   ELSE LLINENR:= LLINENR+L1
END;

PROCEDURE STATISTIC;
VAR E: PACKED ARRAY[1..50] OF CHAR;
    I: INTEGER;

BEGIN
   ADV(3,3);
   WRITELN(OUTPUT); WRITELN(OUTPUT);
   WRITELN(OUTPUT,LZ,'SOURCE LINES: ',SLINENR:3,'    ERRORS: ',ERR:3,
           '    STORAGE USED: ',MAXMEM:8);
   ADV(3,6);
   WRITELN(OUTPUT);
   WRITE(OUTPUT,LZ,'COMPILER ERROR MESSAGES: ');
   IF ERR=0 THEN WRITELN(OUTPUT,'NONE')
   ELSE BEGIN
      WRITELN(OUTPUT);
      WRITELN(OUTPUT);
      FOR I:= 1 TO MAXERRNO DO BEGIN
         IF ERRORS[I] THEN BEGIN
         CASE I OF
          1:E:='IDENTIFIER EXPECTED                               ';
          2:E:=''';'' EXPECTED                                      ';
          3:E:='''='' EXPECTED                                      ';
          4:E:='IDENTIFIER OR KEYWORD EXPECTED                    ';
          5:E:='''PROGRAM'' EXPECTED                                ';
          6:E:=''')'' EXPECTED                                      ';
          7:E:='EXPRESSION MUST NOT START WITH THIS SYMBOL        ';
          8:E:='IDENTIFIER DECLARED TWICE                         ';
          9:E:='IDENTIFIER NOT DECLARED                           ';
         10:E:='CONSTANT OR INTEGER EXPRESSION OVERFLOW           ';
         11:E:=''']'' EXPECTED                                      ';
         12:E:=''','' EXPECTED                                      ';
         13:E:='''['' EXPECTED                                      ';
         14:E:='''SYM'', ''DIAG'' OR ''TRANS'' EXPECTED                 ';
         15:E:=''' EXPECTED                                        ';
         16:E:='STRING EXCEEDS SOURCE LINE                        ';
         17:E:='''ZERO'', ''IDN'' OR ''CON'' EXPECTED                   ';
         18:E:='''..'' EXPECTED                                     ';
         19:E:=''':='' EXPECTED                                     ';
         20:E:='CONFORMABILITY ERROR OR ILLEGAL SUBRANGE          ';
         21:E:='PRECEEDING FACTOR MUST NOT END WITH THIS SYMBOL   ';
         22:E:='CONFORMABILITY ERROR                              ';
         23:E:='ILLEGAL FUNCTION IDENTIFIER                       ';
         24:E:='MATRIX NOT SQUARE                                 ';
         25:E:='ILLEGAL FORMAT SPECIFIER                          ';
         26:E:='ILLEGAL NUMBER OF DIGITS                          ';
         27:E:='''('' EXPECTED                                      ';
         28:E:='ILLEGAL PROCEDURE IDENTIFIER                      ';
         END;
         ADV(1,1);
         WRITELN(OUTPUT,LZ,I:2,':  ',E);
       END;
     END
   END
END;

PROCEDURE ERROR(N: INTEGER);
BEGIN
   ADV(1,1);
   WRITELN(OUTPUT,LZ,'****',' ':CC-1,'^',N:2);
   ERR:= ERR+1; ERRFLAG:= TRUE;
   ERRORS[N]:= TRUE;
   IF ERR > MAXERR THEN BEGIN
      ADV(1,1);
      WRITELN(OUTPUT,LZ,'MAX. NUMBER OF ERRORS EXCEEDED');
      CLOSEFILES;
      TERMINATE;
   END
END;

(* MATSYT.INC*)
PROCEDURE SYTINSERT(SNAME:XALFA;VAR P:REF;VAR Q: REF);
BEGIN
   IF P = NIL THEN BEGIN
       NEW(P);
       Q:=P;
       P^.LEFT:= NIL;
       P^.RIGHT:= NIL;
       P^.FIRSTREF:= NIL;
       P^.LASTREF:= NIL;
       P^.NAME:= SNAME;
    END ELSE BEGIN
       IF SNAME < P^.NAME THEN SYTINSERT(SNAME,P^.LEFT,Q)
       ELSE IF SNAME > P^.NAME THEN SYTINSERT(SNAME,P^.RIGHT,Q)
    END
END;

FUNCTION SYTSEARCH(SNAME:XALFA; P:REF): REF;
VAR FOUND: BOOLEAN;

BEGIN
   FOUND:= FALSE;
   WHILE (P <> NIL) AND (NOT FOUND) DO BEGIN
      IF P^.NAME = SNAME THEN FOUND:= TRUE
      ELSE IF P^.NAME> SNAME THEN P:= P^.LEFT ELSE P:= P^.RIGHT
      END;
   SYTSEARCH:=P
END;

PROCEDURE ENTERREF(P:REF;SLINENR:INTEGER);
LABEL 99;
VAR T:LREF;

BEGIN
   WITH P^ DO BEGIN
      IF LASTREF <> NIL THEN BEGIN
         IF LASTREF^.LINENO = SLINENR THEN GOTO 99;
      END;
      NEW(T);
      IF FIRSTREF = NIL THEN BEGIN
         FIRSTREF:=T;
         T^.NEXTREF:= NIL;
         T^.LINENO:= SLINENR;
    LASTREF:=T;
      END ELSE BEGIN
         T^.NEXTREF:= NIL;
         T^.LINENO:= SLINENR;
         LASTREF^.NEXTREF:=T;
         LASTREF:=T
      END
   END;
99:END;

PROCEDURE ENTERCONSTANT(NAM:XALFA;STATUS:BOOLEAN;XVALUE:INTEGER);
VAR P: REF;
BEGIN
   P:= NIL;
   SYTINSERT(NAM,ROOT,P);
   IF P= NIL THEN ERROR(8)
   ELSE WITH P^ DO BEGIN
      KIND:= CONSTANT;
      INVALID:= STATUS;
      VAL:= XVALUE;
      CONSTANTENTERED:= TRUE;
      ENTERREF(P,SLINENR);
   END;
END;

PROCEDURE GETCONSTANT(NAM:XALFA;VAR BAD: BOOLEAN; VAR XVALUE:INTEGER);
VAR P: REF;
BEGIN
   P:= SYTSEARCH(NAM,ROOT);
   IF (P=NIL) THEN BEGIN
      ERROR(9);
      BAD:= TRUE
   END ELSE IF P^.KIND <> CONSTANT THEN BEGIN
      ERROR(9);
      BAD:= TRUE
   END ELSE BEGIN
      BAD:= P^.INVALID;
      XVALUE:= P^.VAL;
      ENTERREF(P,SLINENR);
   END
END;

PROCEDURE ENTERMATRIX(NAM:XALFA;STATUS:BOOLEAN;LINES,ROWS:INTEGER;
                      XADRESS:INTEGER);
VAR P: REF;
BEGIN
   P:= NIL;
   SYTINSERT(NAM,ROOT,P);
   IF P= NIL THEN ERROR(8)
   ELSE WITH P^ DO BEGIN
      KIND:= MATRIX;
      INVALID:= STATUS;
      L:= LINES;
      R:= ROWS;
      XADR:= XADRESS;
      MATRIXENTERED:= TRUE;
      ENTERREF(P,SLINENR);
   END;
END;

PROCEDURE GETMATRIX(NAM:XALFA;VAR BAD: BOOLEAN; VAR LINES,ROWS:INTEGER;
                    VAR XADRESS:INTEGER);
VAR P: REF;
BEGIN
   P:= SYTSEARCH(NAM,ROOT);
   IF (P=NIL) THEN BEGIN
      ERROR(9);
      BAD:= TRUE
   END ELSE IF P^.KIND <> MATRIX THEN BEGIN
      ERROR(9);
      BAD:= TRUE
   END ELSE BEGIN
      BAD:= P^.INVALID;
      LINES:= P^.L;
      ROWS:= P^.R;
      XADRESS:=P^.XADR;
      ENTERREF(P,SLINENR);
   END
END;

PROCEDURE PRINTTREE(P:REF;OUTTYP:CONSTMAT);
VAR T: LREF;
    I: INTEGER;
    ANZREF: INTEGER;

BEGIN
   IF P <> NIL THEN
   WITH P^ DO BEGIN
      PRINTTREE(LEFT,OUTTYP);
      IF KIND = OUTTYP THEN BEGIN
         ADV(1,1);
         IF OUTTYP= CONSTANT THEN BEGIN
            WRITE(OUTPUT,LZ,NAME:20,' ');
            IF INVALID THEN WRITE(OUTPUT,'?':7,' ':6)
            ELSE WRITE(OUTPUT,VAL:7,' ':6);
          END ELSE BEGIN
            WRITE(OUTPUT,LZ,NAME:20,' ');
            IF INVALID THEN WRITE(OUTPUT,'?':7,' ','?':7,'  ')
            ELSE WRITE(OUTPUT,L:7,' ',R:7,'  ')
          END;
          ANZREF:= (FORMWIDTH- 39) DIV 5;
          I:=0;
          T:= FIRSTREF;
          REPEAT
             IF I=ANZREF THEN BEGIN
                I:=0;
                WRITELN(OUTPUT);
                WRITE(OUTPUT,LZ,' ':38);
             END;
             WRITE(OUTPUT,T^.LINENO:5);
             I:=I+1;
             T:=T^.NEXTREF
          UNTIL T= NIL;
          WRITELN(OUTPUT)
       END;
      PRINTTREE(RIGHT,OUTTYP)
   END
END;

(* MATSCAN.INC *)
PROCEDURE GETCH;
BEGIN IF CC= LL THEN BEGIN
   IF EOF(INPUT)THEN BEGIN
      ADV(1,1);
      WRITELN(OUTPUT,LZ,'INCOMPLETE PROGRAM');
      CLOSEFILES;
      TERMINATE;
   END ELSE BEGIN
      SLINENR:= SLINENR+1;
      ADV(1,1);
      LL:= 0; CC:= 0;
      WRITE(OUTPUT,LZ,SLINENR:3,'  ');
      WHILE NOT EOL(INPUT) DO BEGIN
         IF LL < (LINELENGTH-1) THEN BEGIN
         LL:=LL+1;
         READ(INPUT,CH);
         WRITE(OUTPUT,CH);LINE[LL]:=CH
         END
      ELSE READ(INPUT,CH)
      END;
      LL:=LL+1;
      LINE[LL]:=' ';
      WRITELN(OUTPUT)
   END
  END;
  CC:= CC+1; CH:= LINE[CC];
END(* GETCH *);

PROCEDURE GETSYM;
  VAR I,J,K : INTEGER;

BEGIN (* GETSYM *)
  WHILE CH =' ' DO GETCH;
  REPEAT
  IF CH='/' THEN BEGIN
     REPEAT
        GETCH
     UNTIL (CH= '/');
     GETCH;
     WHILE CH =' ' DO GETCH
  END;
  UNTIL CH <>'/';
  IF CH IN ['A'..'Z','A'..'Z'] THEN
    BEGIN(* IDENTIFIER OR RESERVED WORD *)
    K:=0;
    REPEAT IF K < AL THEN
      BEGIN K:= K+1; A[K]:= CH
      END;
      GETCH
    UNTIL NOT( (CH IN ['A'..'Z','0'..'9']) OR (CH IN ['A'..'Z','_']));
    IF K>= KK THEN KK:= K ELSE
      REPEAT A[KK]:= ' '; KK:= KK-1
      UNTIL KK= K;
    ID:= A; I:= 1; J:= NORW;
    REPEAT K:= (I+J)DIV 2;
      IF ID <= TOKEN[K] THEN BEGIN
        J:= K-1;
      END;
      IF ID >= TOKEN[K] THEN BEGIN
         I:= K+1;
      END;
    UNTIL I> J;
    IF I-1 > J THEN SYM:= WSYM[K] ELSE SYM := IDENT;
  END ELSE
  IF CH IN ['0'..'9'] THEN
  BEGIN (* NUMBER *) K:= 0; NUM:= 0; SYM:= NUMBER;
    REPEAT NUM:= 10 * NUM + (ORD(CH)- ORD('0'));
      K:= K+1; GETCH
    UNTIL NOT ( CH IN ['0'..'9']);
    IF K> NMAX THEN ERROR(10)
  END ELSE
  IF CH = ':' THEN
  BEGIN GETCH;
    IF CH = '=' THEN
    BEGIN SYM:= BECOMES; GETCH
    END ELSE SYM:= NUL;
  END ELSE
  IF CH= '.' THEN
  BEGIN GETCH;
    IF CH = '.' THEN
    BEGIN SYM:= TWOPOINT; GETCH
    END ELSE SYM:= NUL;
  END ELSE
    BEGIN SYM := SSYM[CH]; GETCH
    END;
  END(* GETSYM *);

(* MATMEM.INC *)
FUNCTION ALLOC(STYPE: MEMTYPE;L,R:INTEGER):INTEGER;
VAR MEM: INTEGER;
BEGIN
   CASE STYPE OF
   MAIN: BEGIN
            ALLOC:= MAINEND;
            MAINEND:= MAINEND+ L*R;  (* LONG *)
            SCRATCHEND:= MAINEND;
          END;
   SCRATCH: BEGIN
            ALLOC:= SCRATCHEND;
            SCRATCHEND:= SCRATCHEND+L*R;       (* LONG *)
            END;
   TEMP: BEGIN
            TEMPEND:= TEMPEND-L*R;             (* LONG *)
            ALLOC:= TEMPEND;
         END;
   END;
   MEM:= SCRATCHEND-TEMPEND;                   (* LONG *)
   IF MEM > MAXMEM THEN MAXMEM:= MEM           (* LONG *)
END;

PROCEDURE FREE(STYPE: MEMTYPE);
BEGIN
   CASE STYPE OF
   MAIN : MAINEND:=1;
   SCRATCH: SCRATCHEND:= MAINEND;
   TEMP: TEMPEND:=0;
   END
END;

(* MATCODE.INC *)
PROCEDURE GENHEADER(OPCODE,FLINES,OPT1,OPT2,OPT3: INTEGER; EXTRA: INTEGER);
VAR P:CODEREF;
BEGIN
   NEW(P);
   IF FIRSTCODE= NIL THEN BEGIN
      FIRSTCODE:= P;
      LASTCODE:= P
   END ELSE BEGIN
      LASTCODE^.NEXTCODE:= P;
      LASTCODE:=P
   END;
   WITH P^ DO BEGIN
      NEXTCODE:= NIL;
      CODEKIND:= CODE;
      CDXADR:= EXTRA;
      CDL:= OPCODE;
      CDR:= SLINENR;
      CDL1:= FLINES;
      CDL2:= OPT1;
      CDR1:= OPT2;
      CDR2:= OPT3
   END
END;

PROCEDURE GENLINE(NAME:XALFA;XADR:INTEGER;L,R,L1,L2,R1,R2: INTEGER);
VAR P: CODEREF;
BEGIN
   NEW(P);
   LASTCODE^.NEXTCODE:= P;
   LASTCODE:=P;
   WITH P^ DO BEGIN
      NEXTCODE:= NIL;
      CODEKIND:= CODE;
      CDXADR:= XADR;
      CDL:=L;
      CDR:=R;
      CDL1:= L1;
      CDL2:= L2;
      CDR1:= R1;
      CDR2:= R2
   END
END;

PROCEDURE GENTEXT(TXT: XALFA);
VAR P: CODEREF;
BEGIN
   NEW(P);
   LASTCODE^.NEXTCODE:= P;
   LASTCODE:=P;
   WITH P^ DO BEGIN
      NEXTCODE:= NIL;
      CODEKIND:= CHARS;
      CODETEXT:= TXT
   END
END;

PROCEDURE OUTPUTCODE;
VAR P: CODEREF;
BEGIN
   WRITELN(LOGO,PROGNAME,' ',MAXMEM:10);
   P:= FIRSTCODE;
   WHILE P<> NIL DO BEGIN
      WITH P^ DO BEGIN
         IF CODEKIND= CHARS THEN WRITELN(LOGO,CODETEXT)
         ELSE BEGIN
            WRITELN(LOGO,' ',CDXADR:10,' ',CDL:4,' ',CDR:4,' ',
                    CDL1:4,' ',CDL2:4,' ',CDR1:4,' ',CDR2:4)
         END;
         P:= NEXTCODE;
      END
   END;
END;




PROCEDURE TEST(S1,S2:SYMSET;N:INTEGER);
BEGIN
   IF NOT (SYM IN S1) THEN BEGIN
      ERROR(N);
      S1:= S1+S2;
      WHILE NOT (SYM IN S1) DO GETSYM
   END
END;

PROCEDURE ERRSKIP1(S1:SYMSET;N:INTEGER);
BEGIN
   ERROR(N);
   WHILE NOT (SYM IN S1) DO GETSYM
END;

PROCEDURE PROG;
LABEL 99;

PROCEDURE PROGLINE;

BEGIN
   GETSYM; IF SYM <> IDENT THEN ERROR(1)
   ELSE BEGIN
      PROGNAME:= ID;
      GETSYM;
   END;
   TEST([SEMICOLON],[],2);
   GETSYM
END;

PROCEDURE INTEX(FSYS:SYMSET;VAR IXVALUE: INTEGER;VAR VALID: BOOLEAN);
VAR TXVALUE: INTEGER;

FUNCTION INTEXPRESSION(FSYS:SYMSET):INTEGER; FORWARD;

FUNCTION INTFACTOR(FSYS:SYMSET): INTEGER;
VAR R: INTEGER;
    I: INTEGER;
BEGIN
   TEST(FACBEGSYS,FSYS,7);
   WHILE SYM IN FACBEGSYS DO BEGIN
      IF SYM = IDENT THEN BEGIN
         GETCONSTANT(ID,ERRFLAG,I);
         INTFACTOR:=I;
         GETSYM
      END
      ELSE IF SYM = NUMBER THEN BEGIN
         IF NUM > MAXNUM THEN BEGIN
             ERROR(10);
             NUM:=0
          END;
          INTFACTOR:= NUM;
          GETSYM
      END ELSE  IF SYM = LPAREN THEN BEGIN
         GETSYM;
         R:= INTEXPRESSION([RPAREN] + FSYS);
         INTFACTOR:=R;
         IF SYM = RPAREN THEN GETSYM ELSE ERROR(6)
      END;
      TEST(FSYS,[LPAREN],6)
   END
END;

FUNCTION INTTERM(FSYS:SYMSET):INTEGER;
VAR TXVALUE: INTEGER;

BEGIN
   TXVALUE:= INTFACTOR(FSYS+[TIMES]);
   WHILE SYM = TIMES DO BEGIN
      GETSYM;
      TXVALUE:= TXVALUE* INTFACTOR(FSYS+[TIMES])  (* LONG *)
   END;
   INTTERM:= TXVALUE
END;

FUNCTION INTEXPRESSION; 
VAR EXVALUE: INTEGER;
    OP: SYMBOL;

BEGIN
   IF SYM IN [PLUS,MINUS] THEN BEGIN
      OP:=SYM;
      GETSYM;
      EXVALUE:= INTTERM(FSYS+[PLUS,MINUS]);
      IF OP = MINUS THEN EXVALUE:= - EXVALUE
   END ELSE EXVALUE:= INTTERM(FSYS+[PLUS,MINUS]);
   WHILE SYM IN [PLUS,MINUS] DO BEGIN
      OP:=SYM;
      GETSYM;
      IF OP = MINUS THEN EXVALUE:= EXVALUE - INTTERM(FSYS+[PLUS,MINUS])
      ELSE EXVALUE:= EXVALUE + INTTERM(FSYS+[PLUS,MINUS])    (* LONG *)
   END;
   INTEXPRESSION:= EXVALUE
END;

BEGIN (* INTEX *)
   ERRFLAG:= FALSE;
   TXVALUE:= INTEXPRESSION(FSYS);
   IF ABS(TXVALUE)> MAXNUM THEN BEGIN
       ERROR(10);
       TXVALUE:= 0
   END;
   IXVALUE:= TXVALUE;
   VALID:= ERRFLAG
END;

PROCEDURE DEVMAT(VAR NAME: XALFA;VAR MATBAD:BOOLEAN;VAR L,R:INTEGER;
                 STOP:SYMSET);
VAR    TMPBAD: BOOLEAN;
BEGIN
   IF SYM = IDENT THEN BEGIN
      NAME:=ID;
      GETSYM;
      IF SYM = LBRACKET THEN BEGIN
         GETSYM;
         INTEX(STATBEGSYS+[COMMA,RBRACKET,SEMICOLON],L,MATBAD);
         IF SYM = COMMA THEN BEGIN
            GETSYM;
            INTEX(STATBEGSYS+[RBRACKET,SEMICOLON],R,TMPBAD);
            MATBAD:= MATBAD OR TMPBAD;
            IF SYM = RBRACKET THEN GETSYM
            ELSE ERRSKIP1(STOP,11)
         END ELSE ERRSKIP1(STOP,12)
      END ELSE ERRSKIP1(STOP,13);
   END ELSE BEGIN
      ERRSKIP1(STOP,1);
      MATBAD:= TRUE;
   END;
END;


PROCEDURE SUBRANGE(FSYS:SYMSET;VAR MATBAD, SUB:BOOLEAN;
                   VAR L1,L2,R1,R2:INTEGER);
VAR TMPBAD: BOOLEAN;

BEGIN
      MATBAD:= FALSE;
      IF SYM = LBRACKET THEN BEGIN
         GETSYM;
         SUB:= TRUE;
         INTEX(FSYS+[TWOPOINT,COMMA,RBRACKET],L1,MATBAD);
         IF SYM = TWOPOINT THEN BEGIN
            GETSYM;
            INTEX(FSYS+[COMMA,RBRACKET],L2,TMPBAD);
            MATBAD:= MATBAD OR TMPBAD;
            IF SYM = COMMA THEN BEGIN
               GETSYM;
               INTEX(FSYS+[TWOPOINT,COMMA,RBRACKET],R1,TMPBAD);
               MATBAD:= MATBAD OR TMPBAD;
               IF SYM= TWOPOINT THEN BEGIN
                  GETSYM;
                  INTEX(FSYS+[RBRACKET,SEMICOLON],R2,TMPBAD);
                  MATBAD:= MATBAD OR TMPBAD;
                  IF SYM = RBRACKET THEN GETSYM
                  ELSE ERROR (11)
               END ELSE ERROR(18)
            END ELSE ERROR(12)
         END ELSE ERROR(18)
      END ELSE SUB:= FALSE;
END;

PROCEDURE MATEXPRESSION(FSYS:SYMSET;VAR MATBAD: BOOLEAN;VAR L,R:INTEGER;
                        VAR XADR: INTEGER );
VAR TMPBAD: BOOLEAN;
    L1,L2,R1,R2: INTEGER;
    XADR1,XADR2,XADR3: INTEGER;
    TMPSYM: SYMBOL;

PROCEDURE  MATTERM(FSYS:SYMSET;VAR MATBAD: BOOLEAN; VAR L,R:INTEGER;
                   VAR XADR: INTEGER);
VAR TMPBAD: BOOLEAN;
    L1,L2,R1,R2,L3,R3: INTEGER;
    XADR2,XADR3: INTEGER;

PROCEDURE MATFACTOR(FSYS: SYMSET; VAR MATBAD:BOOLEAN; VAR L,R: INTEGER;
                    VAR XADR: INTEGER);
VAR   NAME: XALFA;
      LL,RR,L1,L2,R1,R2: INTEGER;
      TMPBAD,SUB: BOOLEAN;
      P: REF;
      TYP: CONSTMAT;
      XVALUE: INTEGER;
      XADR0: INTEGER;

PROCEDURE MATFUNCTION(FSYS:SYMSET;NAME:XALFA;VAR MATBAD:BOOLEAN;VAR L,R:INTEGER;
                      VAR XADR: INTEGER);
VAR I,J,K: INTEGER;
   TMPBAD: BOOLEAN;
   LL,RR:  INTEGER;
   TMPXADR,XADRARG: INTEGER;
   FC:  INTEGER;

BEGIN
   TMPBAD:= FALSE;
   I:=1;
   J:= NORF;
   REPEAT
      K:=(I+J) DIV 2;
      IF NAME <= FUNCT[K].FNAME THEN J:=K-1;
      IF NAME >= FUNCT[K].FNAME THEN I:=K+1
   UNTIL I>J;
   IF I-1 <= J THEN ERROR(23);
   GETSYM;
   MATEXPRESSION(FSYS,TMPBAD,LL,RR,XADRARG);
   IF SYM <> RPAREN THEN ERROR(6) ELSE GETSYM;
   WITH FUNCT[K] DO BEGIN
      IF (TRCODE[1]=TRCODE[2]) AND (LL <> RR) THEN BEGIN
         ERROR(24);
         TMPBAD:= TRUE
      END;
      IF TRCODE[3]= ONE THEN L:=1;
      IF TRCODE[3]= RW THEN L:=RR;
      IF TRCODE[3]= LN THEN L:=LL;
      IF TRCODE[4]= ONE THEN R:=1;
      IF TRCODE[4]= RW THEN R:=RR;
      IF TRCODE[4]= LN THEN R:=LL;
      IF NOT TMPBAD THEN
      TMPXADR:= ALLOC(SCRATCH,LL*TMPSIZE[1]+TMPSIZE[2],LL)
      ELSE TMPXADR:=0;
      FC:= FCODE
   END;
   MATBAD:= MATBAD OR TMPBAD;
   IF NOT MATBAD THEN XADR:= ALLOC(TEMP,L,R)
   ELSE XADR:=0;
   FREE(SCRATCH);
   GENHEADER(FC,2,0,0,0,TMPXADR);
   GENLINE(TEMPSTRING,XADRARG,LL,RR,1,LL,1,RR);
   GENLINE(TEMPSTRING,XADR,L,R,1,L,1,R);
END;

BEGIN
   TMPBAD:= FALSE;
   TEST(FACBEGSYS,FSYS,7);
   WHILE SYM IN FACBEGSYS DO BEGIN
      IF SYM = IDENT THEN BEGIN
         NAME:= ID;
         GETSYM;
         IF SYM = LPAREN THEN BEGIN
            MATFUNCTION(FSYS+[RPAREN],NAME,TMPBAD,L,R,XADR);
            MATBAD:= MATBAD OR TMPBAD
         END
         ELSE BEGIN
            P:= SYTSEARCH(NAME,ROOT);
            IF P= NIL THEN TYP:= CONSTANT ELSE TYP:= P^.KIND;
            IF TYP = MATRIX THEN GETMATRIX(NAME,TMPBAD,LL,RR,XADR)
            ELSE BEGIN
               GETCONSTANT(NAME,TMPBAD,XVALUE);
               LL:=1;
               RR:=1;
               IF NOT TMPBAD THEN XADR:= ALLOC(TEMP,LL,RR)
               ELSE XADR:=0;
               GENHEADER(8,0,XVALUE,0,0,XADR);
            END;
            MATBAD:= MATBAD OR TMPBAD;
            SUBRANGE(FSYS,TMPBAD,SUB,L1,L2,R1,R2);
            MATBAD:= MATBAD OR TMPBAD;
            IF SUB AND (NOT MATBAD) THEN BEGIN
                IF (L1<1) THEN MATBAD:= TRUE;
                IF (R1<1) THEN MATBAD:= TRUE;
                IF (L2<1) THEN MATBAD:= TRUE;
                IF (R2<1) THEN MATBAD:= TRUE;
                IF ((L2-L1)>(LL-1)) THEN MATBAD:=TRUE;
                IF ((R2-R1)>(RR-1)) THEN MATBAD:=TRUE;
                IF MATBAD THEN ERROR(20) ELSE BEGIN
                   L:= L2-L1+1;
                   R:= R2-R1+1;
                   XADR0:= XADR;
                   XADR:= ALLOC(TEMP,L,R);
                   GENHEADER(9,2,0,0,0,0);
                   GENLINE(TEMPSTRING,XADR0,LL,RR,L1,L2,R1,R2);
                   GENLINE(TEMPSTRING,XADR,L,R,1,L,1,R)
                END
             END ELSE BEGIN
                L:=LL;
                R:=RR;
             END
          END
       END ELSE IF SYM = LPAREN THEN BEGIN
          GETSYM;
          MATEXPRESSION([RPAREN]+FSYS,MATBAD,L,R,XADR);
          IF SYM= RPAREN THEN GETSYM ELSE ERROR(6)
       END ELSE IF SYM = NUMBER THEN BEGIN
          GETSYM;
          L:=1;
          R:=1;
          XADR:= ALLOC(TEMP,1,1);
          GENHEADER(8,0,NUM,0,0,XADR)
       END;
       TEST(FSYS,[LPAREN],21)
    END;
END;

BEGIN
   TMPBAD:= FALSE;
   MATFACTOR(FSYS+[TIMES],MATBAD,L1,R1,XADR);
   WHILE SYM = TIMES DO BEGIN
      GETSYM;
      MATFACTOR(FSYS+[TIMES],TMPBAD,L2,R2,XADR2);
      MATBAD:= MATBAD OR TMPBAD;
      IF NOT MATBAD THEN BEGIN
         IF (L1=1) AND (R1=1) THEN BEGIN
            L3:= L2;
            R3:= R2
         END ELSE IF (L2=1) AND (R2=1) THEN BEGIN
            L3:= L1;
            R3:= R1;
         END ELSE BEGIN
            IF R1 <> L2 THEN BEGIN
               ERROR(22);
               MATBAD:= TRUE
            END;
            L3:=L1;
            R3:=R2;
         END
      END;
      IF NOT MATBAD THEN XADR3:= ALLOC(TEMP,L3,R3)
      ELSE XADR3:=0;
      GENHEADER(3,3,0,0,0,0);
      GENLINE(TEMPSTRING,XADR,L1,R1,1,L1,1,R1);
      GENLINE(TEMPSTRING,XADR2,L2,R2,1,L2,1,R2);
      GENLINE(TEMPSTRING,XADR3,L3,R3,1,L3,1,R3);
      XADR:= XADR3;
      L1:= L3;
      R1:= R3
   END;
   L:= L1;
   R:= R1;
END;

BEGIN
   MATBAD:= FALSE;
   TMPBAD:= FALSE;
   IF SYM = MINUS THEN BEGIN
      GETSYM;
      MATTERM(FSYS+[PLUS,MINUS],MATBAD,L1,R1,XADR1);
      IF NOT MATBAD THEN XADR:= ALLOC(TEMP,L1,R1)
      ELSE XADR:=0;
      GENHEADER(21,2,0,0,0,0);
      GENLINE(TEMPSTRING,XADR1,L1,R1,1,L1,1,R1);
      GENLINE(TEMPSTRING,XADR,L1,R1,1,L1,1,R1)
   END ELSE BEGIN
      IF SYM= PLUS THEN GETSYM;
      MATTERM(FSYS+[PLUS,MINUS],MATBAD,L1,R1,XADR);
   END;
   WHILE SYM IN [PLUS,MINUS] DO BEGIN
      TMPSYM:= SYM;
      GETSYM;
      MATTERM(FSYS+[PLUS,MINUS],TMPBAD,L2,R2,XADR2);
      MATBAD:= MATBAD OR TMPBAD;
      IF NOT MATBAD THEN BEGIN
         IF (L1 <> L2) OR (R1 <> R2) THEN BEGIN
            ERROR(22);
            MATBAD:= TRUE
         END
      END;
      IF NOT MATBAD THEN XADR3:= ALLOC(TEMP,L1,R1)
      ELSE XADR3:=0;
      IF TMPSYM= MINUS THEN GENHEADER(2,3,0,0,0,0)
      ELSE GENHEADER(1,3,0,0,0,0);
      GENLINE(TEMPSTRING,XADR,L1,R1,1,L1,1,R1);
      GENLINE(TEMPSTRING,XADR2,L1,R1,1,L1,1,R1);
      GENLINE(TEMPSTRING,XADR3,L1,R1,1,L1,1,R1);
      XADR:= XADR3
   END;
   L:= L1;
   R:= R1;
END;



PROCEDURE CONSTDECLARATION;
VAR  IVAL: INTEGER;
     VALID:BOOLEAN;
     CNAME:XALFA;
BEGIN
   IF SYM = IDENT THEN BEGIN
      CNAME:= ID;
      GETSYM;
      IF SYM = EQL THEN BEGIN
         GETSYM;
         INTEX(STATBEGSYS+[COMMA,SEMICOLON],IVAL,VALID);
         ENTERCONSTANT(CNAME,VALID,IVAL)
      END
      ELSE ERROR(3)
      END
   ELSE ERROR(1)
END;

PROCEDURE CONSTSTATEMENT;
BEGIN
   REPEAT
      GETSYM;
      CONSTDECLARATION
   UNTIL SYM <> COMMA
END;

PROCEDURE READSTATEMENT;
VAR L,R: INTEGER;
    NAME: XALFA;
    TSYM: SYMBOL;
    MATBAD: BOOLEAN;
    XADR: INTEGER;

BEGIN
   GETSYM;
   MATBAD:= FALSE;
   DEVMAT(NAME,MATBAD,L,R,[SYMSYM,DIAGSYM,TRANSSYM,SEMICOLON]);
   TSYM:= PRED(SYMSYM);
   IF SYM <> SEMICOLON THEN BEGIN
      IF SYM IN [SYMSYM,DIAGSYM,TRANSSYM] THEN TSYM:= SYM
      ELSE BEGIN
         ERROR(14);
      END;
      GETSYM;
   END;
   IF NOT MATBAD THEN BEGIN
      XADR:= ALLOC(MAIN,L,R);
      ENTERMATRIX(NAME,MATBAD,L,R,XADR);
      GENHEADER(4,1,ORD(TSYM)-ORD(SYMSYM)+1,0,0,0);
      GENLINE(NAME,XADR,L,R,1,L,1,R);
   END
END;

PROCEDURE WRITESTATEMENT;
VAR MATBAD: BOOLEAN;
    L,R:  INTEGER;
    TSYM: SYMBOL;
    FC: CHAR;
    NUMBAD: BOOLEAN;
    NDIG: INTEGER;
    XADR: INTEGER;
BEGIN
   GETSYM;
   MATBAD:= FALSE;
   MATEXPRESSION([COMMA,SYMSYM,DIAGSYM,TRANSSYM,SEMICOLON]
   +STATBEGSYS,MATBAD,L,R,XADR);
   IF SYM = COMMA THEN BEGIN
      GETSYM;
      IF SYM = IDENT THEN FC:= ID[1] ELSE FC:=' ';
      IF NOT (FC IN ['E','F','G']) THEN ERROR(25);
      GETSYM;
      IF SYM = COMMA THEN BEGIN
         GETSYM;
         INTEX(STATBEGSYS+[SYMSYM,DIAGSYM,TRANSSYM,SEMICOLON],NDIG,NUMBAD);
         IF (NOT NUMBAD) AND ((NDIG < 1) OR (NDIG>14)) THEN ERROR(26);
      END ELSE ERROR(12)
   END ELSE BEGIN
      FC:='F';
      NDIG:=4
   END;
   TSYM:= PRED(SYMSYM);
   IF SYM <> SEMICOLON THEN BEGIN
      IF SYM IN [SYMSYM,DIAGSYM,TRANSSYM] THEN BEGIN
         TSYM:= SYM;
         GETSYM;
      END ELSE BEGIN
         ERROR(14);
      END;
   END;
   GENHEADER(5,1,ORD(FC)-ORD('E'),ORD(TSYM)-ORD(SYMSYM)+1,NDIG,0);
   GENLINE(TEMPSTRING,XADR,L,R,1,L,1,R)
END;

PROCEDURE CREATESTATEMENT;
VAR L,R:INTEGER;
    NAME: XALFA;
    TSYM: SYMBOL;
    MATBAD: BOOLEAN;
    XADR: INTEGER;

BEGIN
   GETSYM;
   MATBAD:=FALSE;
   DEVMAT(NAME,MATBAD,L,R,[CONSYM,IDNSYM,ZERSYM,SEMICOLON]);
   TSYM:= CONSYM;
   IF SYM IN [CONSYM,IDNSYM,ZERSYM] THEN BEGIN
      TSYM:= SYM;
      GETSYM
   END ELSE BEGIN
      WRITELN(ORD(SYM));
      ERROR(17);
   END;
   IF (TSYM= IDNSYM) AND (L<>R) THEN BEGIN
      ERROR(24);
      MATBAD:= TRUE;
   END;
   IF NOT MATBAD THEN BEGIN
      XADR:= ALLOC(MAIN,L,R);
      ENTERMATRIX(NAME,MATBAD,L,R,XADR);
      GENHEADER(6,1,ORD(TSYM)-ORD(ZERSYM),0,0,0);
      GENLINE(NAME,XADR,L,R,1,L,1,R)
   END
END;

PROCEDURE PRINTSTATEMENT;
LABEL 99;
VAR COUNT,I,J,FLINES: INTEGER;
    TEMP: XALFA;

BEGIN
   GETSYM;
   TEXTLEN:=0;
   TEST([APOSTROPH],STATBEGSYS+[SEMICOLON],15);
   IF SYM= APOSTROPH THEN BEGIN
      WHILE CH <> '''' DO BEGIN
         IF CC = LL THEN BEGIN
             ERROR(16);
             GOTO 99
         END;
         TEXTLEN:= TEXTLEN+1;
         TEXTBUF[TEXTLEN]:= CH;
         GETCH
      END;
      GETCH;
    END;
99:GETSYM;
   FLINES:= TEXTLEN DIV AL;
   IF (TEXTLEN MOD AL) <> 0 THEN FLINES:= FLINES+1;
   GENHEADER(7,FLINES,TEXTLEN,0,0,0);
   COUNT:=0;
   FOR J:= 1 TO FLINES DO BEGIN
       FOR I:= 1 TO AL DO BEGIN
           COUNT:= COUNT+1;
           IF COUNT > TEXTLEN THEN TEMP[I]:=' '
           ELSE TEMP[I]:= TEXTBUF[COUNT];
       END;
       GENTEXT(TEMP)
    END
END;

PROCEDURE DESTINATION(LL,RR:INTEGER; MATBAD:BOOLEAN; XADR0: INTEGER);
VAR   TMPBAD: BOOLEAN;
      NAME: XALFA;
      SUB: BOOLEAN;
      L1,L2,R1,R2,L,R:INTEGER;
      XADR1: INTEGER;

BEGIN
   MATBAD:= FALSE;
   NAME:= ID;
   GETSYM;
   SUBRANGE(STATBEGSYS,TMPBAD,SUB,L1,L2,R1,R2);
   MATBAD:= MATBAD OR TMPBAD;
   IF NOT SUB THEN BEGIN  (* NOT SUBRANGE *)
      IF SYTSEARCH(NAME,ROOT) = NIL THEN BEGIN (* MATRIX DOES NOT EXIST *)
         IF NOT MATBAD THEN XADR1:= ALLOC(MAIN,LL,RR)
         ELSE XADR1:=0;
         ENTERMATRIX(NAME,MATBAD,LL,RR,XADR1)
      END ELSE BEGIN
         GETMATRIX(NAME,TMPBAD,L,R,XADR1);
         MATBAD:= MATBAD OR TMPBAD;
         IF NOT MATBAD THEN BEGIN
            IF (L<> LL) OR (R<> RR) THEN BEGIN
               ERROR(20);
               MATBAD:= TRUE
            END
         END
      END;
      GENHEADER(9,2,0,0,0,0);
      GENLINE(TEMPSTRING,XADR0,LL,RR,1,LL,1,RR);
      GENLINE(NAME,XADR1,LL,RR,1,LL,1,RR)
   END
   ELSE BEGIN  (* SUBRANGE -- MATRIX MUST EXIST *)
      GETMATRIX(NAME,TMPBAD,L,R,XADR1);
      MATBAD:= MATBAD OR TMPBAD;
      IF SUB AND (NOT MATBAD) THEN BEGIN
         MATBAD:= MATBAD OR (L1< 1);
         MATBAD:= MATBAD OR (R1< 1);
         MATBAD:= MATBAD OR (L2> L);
         MATBAD:= MATBAD OR (R2> R);
         MATBAD:= MATBAD OR ((L2-L1)>(L-1));
         MATBAD:= MATBAD OR ((R2-R1)>(R-1));
         MATBAD:= MATBAD OR ((L2-L1)<>(LL-1));
         MATBAD:= MATBAD OR ((R2-R1)<>(RR-1));
         IF MATBAD THEN ERROR(20)
      END;
      GENHEADER(9,2,0,0,0,0);
      GENLINE(TEMPSTRING,XADR0,LL,RR,1,LL,1,RR);
      GENLINE(NAME,XADR1,L,R,L1,L2,R1,R2);
   END
END;

PROCEDURE ERRSKIP(IERR: INTEGER);
BEGIN
   GETSYM;
   ERROR(IERR);
   WHILE NOT(SYM IN [SEMICOLON]) DO GETSYM
END;

PROCEDURE CALLSTATEMENT;
VAR L,R: INTEGER;
    XADR0,XADR1,XADR2,EXTXADR: INTEGER;
    MATBAD: BOOLEAN;

BEGIN
   GETSYM;
   IF SYM = IDENT THEN
      IF ID = 'SPEC                ' THEN BEGIN
         GETSYM;
         IF SYM = LPAREN THEN GETSYM ELSE ERROR(27);
            MATEXPRESSION(STATBEGSYS+[COMMA],MATBAD,L,R,XADR0);
            IF NOT MATBAD THEN BEGIN
               XADR1:= ALLOC(TEMP,L,R);
               XADR2:= ALLOC(TEMP,L,R);
               EXTXADR:= ALLOC(SCRATCH,L+2,L);
               GENHEADER(51,3,0,0,0,EXTXADR);
               GENLINE(ID,XADR0,L,R,1,L,1,R);
               GENLINE(ID,XADR1,L,R,1,L,1,R);
               GENLINE(ID,XADR2,L,R,1,L,1,R);
            END;
            IF SYM = COMMA THEN BEGIN
               GETSYM;
               DESTINATION(L,R,MATBAD,XADR1);
               IF SYM = COMMA THEN BEGIN
                  GETSYM;
                  DESTINATION(L,R,MATBAD,XADR2);
                  IF SYM = RPAREN THEN GETSYM
                  ELSE ERROR(6)
               END ELSE ERRSKIP(12)
            END ELSE ERRSKIP(12)
      END ELSE ERRSKIP(28)
   ELSE ERRSKIP(1)
END;


PROCEDURE STATEMENT;
VAR  NAME: XALFA;
     MATBAD,TMPBAD,SUB: BOOLEAN;
     L,R,LL,RR,L1,L2,R1,R2: INTEGER;
     XADR0,XADR1: INTEGER;

BEGIN
   MATBAD:= FALSE;
   NAME:= ID;
   GETSYM;
   SUBRANGE(STATBEGSYS,TMPBAD,SUB,L1,L2,R1,R2);
   IF NOT SUB THEN BEGIN  (* NOT SUBRANGE *)
      IF SYM = BECOMES THEN GETSYM ELSE ERROR(19);
      MATEXPRESSION([SEMICOLON]+STATBEGSYS,TMPBAD,LL,RR,XADR0);
      MATBAD:= MATBAD OR TMPBAD;
      IF SYTSEARCH(NAME,ROOT) = NIL THEN BEGIN (* MATRIX DOES NOT EXIST *)
         IF NOT MATBAD THEN
            XADR1:= ALLOC(MAIN,LL,RR)
         ELSE XADR1:=0;
         ENTERMATRIX(NAME,MATBAD,LL,RR,XADR1)
      END ELSE BEGIN
         GETMATRIX(NAME,TMPBAD,L,R,XADR1);
         MATBAD:= MATBAD OR TMPBAD;
         IF NOT MATBAD THEN BEGIN
            IF (L<> LL) OR (R<> RR) THEN BEGIN
               ERROR(20);
               MATBAD:= TRUE
            END
         END
      END;
      GENHEADER(9,2,0,0,0,0);
      GENLINE(TEMPSTRING,XADR0,LL,RR,1,LL,1,RR);
      GENLINE(NAME,XADR1,LL,RR,1,LL,1,RR)
   END
   ELSE BEGIN  (* SUBRANGE -- MATRIX MUST EXIST *)
      GETMATRIX(NAME,TMPBAD,LL,RR,XADR1);
      MATBAD:= MATBAD OR TMPBAD;
      IF SYM = BECOMES THEN GETSYM ELSE ERROR(19);
      MATEXPRESSION([SEMICOLON]+STATBEGSYS,TMPBAD,L,R,XADR0);
      MATBAD:= MATBAD OR TMPBAD;
      IF SUB AND (NOT MATBAD) THEN BEGIN
         MATBAD:= MATBAD OR (L1< 1);
         MATBAD:= MATBAD OR (R1< 1);
         MATBAD:= MATBAD OR (L2> LL);
         MATBAD:= MATBAD OR (R2> RR);
         MATBAD:= MATBAD OR ((L2-L1)>(LL-1));
         MATBAD:= MATBAD OR ((R2-R1)>(RR-1));
         MATBAD:= MATBAD OR ((L2-L1)<>(L-1));
         MATBAD:= MATBAD OR ((R2-R1)<>(R-1));
         IF MATBAD THEN ERROR(20)
      END;
      GENHEADER(9,2,0,0,0,0);
      GENLINE(TEMPSTRING,XADR0,L,R,1,L,1,R);
      GENLINE(NAME,XADR1,LL,RR,L1,L2,R1,R2);
   END
END;

BEGIN
   IF SYM <> PROGRAMSYM THEN ERROR(5) ELSE PROGLINE;
   REPEAT
      IF NOT (SYM IN STATBEGSYS) THEN BEGIN
         ERROR(4);
         REPEAT
            GETSYM
         UNTIL SYM IN STATBEGSYS
      END;
      CASE SYM OF
      CONSTSYM: CONSTSTATEMENT;
      READSYM: READSTATEMENT;
      WRITESYM: WRITESTATEMENT;
      CREATESYM: CREATESTATEMENT;
      PRINTSYM: PRINTSTATEMENT;
      CALLSYM: CALLSTATEMENT;
      ENDSYM: GOTO 99;
      IDENT: STATEMENT;
      END;
      FREE(TEMP);
      IF SYM = SEMICOLON THEN GETSYM ELSE ERROR(2)
   UNTIL FALSE;
99:END;

PROCEDURE SETF(INDEX:INTEGER;NAME: XALFA;T1,T2,T3,T4:TRTYPE;
               S1,S2,S3,S4,FC:INTEGER);
BEGIN
   WITH FUNCT[INDEX] DO BEGIN
      FNAME:= NAME;
      TRCODE[1]:=T1;
      TRCODE[2]:= T2;
      TRCODE[3]:= T3;
      TRCODE[4]:= T4;
      TMPSIZE[1]:= S1;
      TMPSIZE[2]:= S2;
      TMPSIZE[3]:= S3;
      TMPSIZE[4]:= S4;
      FCODE:= FC
   END
END;

PROCEDURE INIT;
VAR I: INTEGER;
    CH1: CHAR;

BEGIN
  FOR CH1:= CHR (0) TO CHR(CHSETSIZE-1) DO SSYM [CH1]:= NUL;
  TOKEN[ 1]:='CALL                ';
  TOKEN[ 2]:='CONST               ';
  TOKEN[ 3]:='CON                 ';
  TOKEN[ 4]:='CREATE              ';
  TOKEN[ 5]:='DIAG                ';
  TOKEN[ 6]:='END                 ';
  TOKEN[ 7]:='IDN                 ';
  TOKEN[ 8]:='PRINT               ';
  TOKEN[ 9]:='PROGRAM             ';
  TOKEN[10]:='READ                ';
  TOKEN[11]:='SYM                 ';
  TOKEN[12]:='TRANS               ';
  TOKEN[13]:='WRITE               ';
  TOKEN[14]:='ZERO                ';
  WSYM[ 1]:= CALLSYM;  WSYM[ 2]:= CONSTSYM;
  WSYM[ 3]:= CONSYM; WSYM[ 4]:= CREATESYM;
  WSYM[ 5]:= DIAGSYM; WSYM[ 6]:= ENDSYM;
  WSYM[ 7]:= IDNSYM; WSYM[ 8]:= PRINTSYM;
  WSYM[ 9]:= PROGRAMSYM; WSYM[10]:= READSYM;
  WSYM[11]:= SYMSYM  ; WSYM[12]:= TRANSSYM;
  WSYM[13]:= WRITESYM; WSYM[14]:= ZERSYM;
  SSYM['+']:= PLUS; SSYM['-']:= MINUS;
  SSYM['*']:= TIMES; SSYM['/']:= SLASH;
  SSYM['(']:= LPAREN; SSYM[')']:= RPAREN;
  SSYM['=']:= EQL;SSYM[',']:= COMMA;
  SSYM[';']:= SEMICOLON;SSYM['[']:= LBRACKET;
  SSYM[']']:= RBRACKET;SSYM['#']:= SHARP;
  SSYM['''']:= APOSTROPH;
  SETF( 1,'CHOL                ',LN,LN,LN,LN,0,1,0,0,34);
  SETF( 2,'CNORM               ',LN,LN,ONE,ONE,0,0,0,0,25);
  SETF( 3,'CSUM                ',LN,RW,ONE,RW,0,0,0,0,30);
  SETF( 4,'DET                 ',LN,LN,ONE,ONE,1,1,0,0,28);
  SETF( 5,'DIAGONAL            ',LN,LN,LN,LN,0,0,0,0,33);
  SETF( 6,'DINV                ',LN,LN,LN,LN,0,0,0,0,24);
  SETF( 7,'FNORM               ',LN,LN,ONE,ONE,0,0,0,0,26);
  SETF( 8,'INQ                 ',LN,LN,LN,LN,1,1,0,0,23);
  SETF( 9,'INV                 ',LN,LN,LN,LN,0,1,0,0,22);
  SETF(10,'PSINV               ',LN,LN,LN,LN,1,2,0,0,32);
  SETF(11,'RNORM               ',LN,LN,ONE,ONE,0,0,0,0,27);
  SETF(12,'RSUM                ',LN,RW,LN,ONE,0,0,0,0,29);
  SETF(13,'SPUR                ',LN,LN,ONE,ONE,0,0,0,0,35);
  SETF(14,'TRN                 ',LN,RW,RW,LN,0,0,0,0,31);
  STATBEGSYS:= [IDENT,CONSTSYM,READSYM,WRITESYM,CREATESYM,PRINTSYM,ENDSYM,
               CALLSYM];
  FACBEGSYS:=  [IDENT,NUMBER,LPAREN];
  MATRIXENTERED:= FALSE;
  CONSTANTENTERED:= FALSE;
  MAXMEM:=0;ERRFLAG:=FALSE;
  SLINENR:=0;PAGENO:=0;LLINENR:= FORMLEN+1;
  FOR I:=1 TO MAXERRNO DO ERRORS[I]:= FALSE;
  ROOT:= NIL; FREE(MAIN);FREE(TEMP);FREE(SCRATCH);
  CC:= 0; LL:= 0; CH:=' ';KK:= AL;ERR:=0;GETSYM;
  ADV(0,0);FIRSTCODE:= NIL; LASTCODE:= NIL
END;

PROCEDURE PRINTTABLE;
VAR I: INTEGER;
    NMINUS: INTEGER;

BEGIN
   NMINUS:= FORMWIDTH-1;
   IF CONSTANTENTERED THEN BEGIN
      ADV(8,12);
      WRITELN(OUTPUT);
      WRITELN(OUTPUT);
      WRITELN(OUTPUT,LZ,'CONSTANTS'); WRITE(OUTPUT,LZ);
      FOR I:= 1 TO 9 DO WRITE(OUTPUT,'-');WRITELN(OUTPUT);
      WRITELN(OUTPUT);
      WRITELN(OUTPUT,LZ,'NAME                 ','VALUE       ',
                        '     REFERENCES');
      WRITE(OUTPUT,LZ);
      FOR I:= 1 TO NMINUS DO WRITE(OUTPUT,'-');WRITELN(OUTPUT);
      WRITELN(OUTPUT);
      PRINTTREE(ROOT,CONSTANT);
   END;
   IF MATRIXENTERED THEN BEGIN
      ADV(8,12);
      WRITELN(OUTPUT);
      WRITELN(OUTPUT);
      WRITELN(OUTPUT,LZ,'MATRIX VARIABLES');WRITE(OUTPUT,LZ);
      FOR I:= 1 TO 16 DO WRITE(OUTPUT,'-');WRITELN(OUTPUT);
      WRITELN(OUTPUT);
      WRITELN(OUTPUT,LZ,'NAME                 ','  LINES    ROWS ',
                        '   REFERENCES');
      WRITE(OUTPUT,LZ);
      FOR I:= 1 TO NMINUS DO WRITE(OUTPUT,'-');
      WRITELN(OUTPUT);
      PRINTTREE(ROOT,MATRIX);
   END
END;

BEGIN(* MAIN PROGRAM *)
  INITFILES;
  INIT;
  PROG;
  PRINTTABLE;
  STATISTIC;
  IF ERR = 0 THEN OUTPUTCODE ELSE TERMINATE;
  CLOSEFILES;
END.
~eor
PROGRAM TEST;
/ MATRIX IMPLEMENTATIONS TESTPROGRAMM /
READ A[5,4]; READ P[4,4]; READ P1[4,4] SYM ; READ P2[4,4] DIAG;
/ AUSDRUCK EINER NORMALEN MATRIX /
PRINT 'MATRIX [5,4]';
WRITE A;
/ AUSDRUCK EINER TRANSPONIERTEN MATRIX /
PRINT 'MATRIX [5,4] AUSDRUCK TRANSPONIERT';
WRITE A TRANS;
/ AUSDRUCK EINER NORMALEN MATRIX /
PRINT 'MATRIX [4,4]';
WRITE P;
/ AUSDRUCK DES OBEREN DREIECKS /
PRINT 'MATRIX [4,4] AUSDRUCK SYMMETRISCH';
WRITE P SYM;
/ AUSDRUCK DER DIAGONALEN /
PRINT 'MATRIX [4,4] AUSDRUCK DER DIAGONALEN';
WRITE P DIAG;
/ TEST DER RECHENFUNKTIONEN /
/ SIND DIE EINGABEMATRITZEN P UND P1 GLEICH UND IST P2 GLEICH DER
  DIAGONALEN VON P ? /
Z0:=(P-P1)+(DIAGONAL(P)-P2);
N:= TRN(A)*A; CREATE E1[4,4] IDN;
/ INVERSE EINER SYMMETRISCHEN POS. DEF. MATRIX BERECHNEN /
Q1:=INV(N); Q2:= INQ(N); Q3:= PSINV(N);
/ Z1 MUSS NULL WERDEN ! /
Z1:= (N*Q1+N*Q2+N*Q3)*INV(3)-E1;
/ TEST DER INVERSEN EINER DIAGONALMATRIX, Z2 MUSS NULL WERDEN ! /
Z2:= DIAGONAL(N)*DINV(DIAGONAL(N))-E1;
/ TEST DER CHOLESKYZERLEGUNG, Z3 MUSS NULL WERDEN ! /
Z3:= N-(TRN(CHOL(N))*CHOL(N));
/ TEST DER SPEKTRALZERLEGUNG, Z4 MUSS NULL WERDEN ! /
CALL SPEC(N,S,D);Z4:= N-(S*D*TRN(S));
CREATE Z5[4,4] ZERO;
Z:=Z1+Z2+Z3+Z4+Z5; RESULT0:= CSUM(RSUM(Z));
/ TEST DER NORMFUNKTIONEN /
CREATE E2[4,4] CON; RESULT1:=CNORM(E2)-RNORM(E2)+FNORM(E2)-4;
/ TEST DER DETERMINANTENBERECHNUNG, DET(N) WIRD ZUR KONTROLLE AUS SPEKTRAL-
  ZERLEGUNG BERECHNET/
RESULT2:=DET(N)-(D[1..1,1..1]*D[2..2,2..2]*D[3..3,3..3]*D[4..4,4..4]);
/ TEST PSEUDOINVERSE /
N1:=A*TRN(A); QI:= PSINV(N1);
Z6:= (N1*QI*N1)-N1 +(QI*N1*QI)-QI + TRN(N1*QI)-N1*QI + TRN(QI*N1)- QI*N1;
RESULT3:= CSUM(RSUM(Z6));
/ TEST DER SUB- UND BLOCKMATRIXFUNKTIONEN /
CREATE B[2,3] ZERO;
B[1..1,1..1]:=4; B[1..1,2..2]:=-2; B[1..1,3..3]:=6;
B[2..2,1..1]:=1; B[2..2,2..2]:=5;  B[2..2,3..3]:=9;
RESULT4:= CSUM(B[1..2,1..1])+CSUM(B[1..2,2..2])+
CSUM(B[1..2,3..3])-23;
RESULT:= RESULT0+RESULT1+RESULT2+RESULT3+RESULT4;
PRINT 'HIER MUSS NULL RAUSKOMMEN';
WRITE RESULT,E,10;
END
~eor
      PROGRAM MATEXE(TAPE5,TAPE6,TAPE99)
      IMPLICIT LOGICAL(A-Z)
C----------------------------------------------------------------------
C
C     PROGRAM M A T E X E
C
C     MATRIX E X E C U T E R
C
C     NOTE: YOU WILL FIND SUBROUTINES IN THIS PROGRAM WHICH ARE COMPATIBLE
C     TO THE NAG LIBRARY BECAUSE THIS PROGRAM RAN ON A CDC CYBER DECADES AGO
C     WHERE THIS LIBRARY WAS INSTALLED. TO RUN THIS SOFTWARE ON OTHER
C     COMPUTERS SUBROUTINES WERE ADDED LATER, WHICH HAVE THE SAME PROGRAMMING
C     INTERFACE AS THEIR NAG COUNTERPARTS. THEY ARE N O T FROM THE NAG
C     LIBRARY BUT SHOULD PERFORM IN A SIMILAR WAY.
C
C     AUTHOR:   JOACHIM SIEBOLD
C
C
C     DEVELOPMENT HISTORY
C
C     DATE        PROGRAMMER     MODIFICATION
C     --------    ----------     ------------
C     04.06.86    J. SIEBOLD     CODED AND DOCUMENTED
C
C     THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR
C     MODIFY IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE
C     AS PUBLISHED BY THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2
C     OF THE LICENSE, OR (AT YOUR OPTION) ANY LATER VERSION.
C
C     THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
C     BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C     MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
C     GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C     YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C     ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
C     FOUNDATION, INC., 59 TEMPLE PLACE - SUITE 330, BOSTON, MA  02111-1307, USA.
C
C----------------------------------------------------------------------
C
      INTEGER MAXM,FLEN,FWIDTH,LFNI,LFNO,LFNC
C----------------------------------------------------------------------
C
C     !! PROGRAM INSTALLATION PARAMETERS !!
C
C     FLEN:   OUTPUT PAGESIZE (LINES)
C     FWIDTH: OUTPUT PAGE WIDTH
C     LFNI:   LOGICAL UNIT NO OF STANDARD INPUT
C     LFNO:   LOGICAL UNIT NO OF STANDARD OUTPUT
C     LFNC:   LOGICAL UNIT NO OF LOGO FILE
C
C----------------------------------------------------------------------
C
      PARAMETER(FLEN=68,FWIDTH=80,LFNI=5,LFNO=6,LFNC=99)
C
      LOGICAL EOF
C
C
C
      INTEGER LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2
      INTEGER LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC
      INTEGER SLINE,OPCODE,OPT1,OPT2,OPT3,EXTADR,FLINES
C
      INTEGER LLINE,MXLINE,FW,LDNI,LDNO,LDNC
      INTEGER MAXRAM,DATSET,MAXPW2,MINPW2
      REAL TOL,EPS
      LOGICAL TEXT
C
      COMMON /COMI/ LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2,
     & LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC,SLINE,OPCODE,
     & OPT1,OPT2,OPT3,EXTADR,FLINES,MAXRAM,LDNI,LDNO,LLINE,MXLINE,
     & FW,LDNC,TEXT,DATSET,TOL,EPS,MAXPW2,MINPW2
C
C
      CHARACTER  INFILE*80,OFILE*80,PROGN*20,TXT*20
      DIMENSION TXT(7)
C
      COMMON /COMC/ INFILE,OFILE,PROGN,TXT
C
C     CMM MEMORY VARIABLES: CMMAR IS THE CMM MANAGED MEMORY
C
      REAL CMMAR(1)
      INTEGER IFWA,IOFF
C
C     INITIATE ALL, DETERMINE MAXRAM FROM FILE LOGO
C
      CALL INIT(FLEN,FWIDTH,LFNI,LFNO,LFNC)
C
C     PRINT HEADER
C
      CALL HEADER
C
C     ALLOCATE WORKSPACE WITH CMM, MAXRAM IS THE REQUIRED SIZE
C     IOFF IS THE ADDRESS OF THE ALLOCATED MEMORY BLOCK IN CMMAR
C     THE PROGRAM WILL ABORT IF THE CMM REQUEST FAILS
C
      CALL CMMALF(MAXRAM,0,0,IFWA)
      IOFF=IFWA-LOCF(CMMAR(1))+1
C
C     INTERPRETING LOOP
C
100   CONTINUE
C
C        READ CODE
C
         CALL  RDCODE(EOF)
         IF (EOF) GOTO 999
         CALL EXECUTE(CMMAR(IOFF))
      GOTO 100
C
C     FINISH ALL
C
999   CALL FINISH
      END
      SUBROUTINE ADSUB(A,B,C,LA,RA,LB,RB,OPT,IFAIL)
      IMPLICIT LOGICAL (A-Z)
C
C     ZWECK: BILDE C:= A+B    FUER OPT=0
C                  C:= A-B    FUER OPT=1
C
C     PARAMETER:    A(LA,RA)    MATRIX A      REAL
C                   B(LB,RB)    MATRIX B  REAL
C                   C(LA,RA)    ERGIBTMATRIX  REAL
C                   LA,RA       DIM(A)        INTEGER
C                   LB,RB       DIM(B)        INTEGER
C                   OPT         S.O.          INTEGER
C                   IFAIL       =0    OK
C                               =1 LA.NE.LB
C                               OR RA.NE.RB
C
C     GENAUIGKEIT:    EINFACHGENAUE ARITHMETIK
C
      INTEGER LA,RA,LB,RB,I,IL,OPT,IFAIL
      REAL A(*),B(*),C(*)
C
      IF(LA.NE.LB.OR.RB.NE.RA)GOTO 1
      IF(OPT.NE.0.AND.OPT.NE.1)GOTO 1
      IFAIL=0
      IL=LA*RA
      IF(OPT.EQ.0)THEN
            DO 10 I=1,IL
                  C(I)=B(I)+A(I)
10          CONTINUE            
            RETURN
      ENDIF
      DO 11 I=1,IL
            C(I)=A(I)-B(I)
11    CONTINUE
      RETURN
1     IFAIL=1
      RETURN
      END
      SUBROUTINE ADV(L1,L2)
      IMPLICIT LOGICAL(A-Z)
      INTEGER L1,L2
C
      INTEGER LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2
      INTEGER LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC
      INTEGER SLINE,OPCODE,OPT1,OPT2,OPT3,EXTADR,FLINES
C
      INTEGER LLINE,MXLINE,FW,LDNI,LDNO,LDNC
      INTEGER MAXRAM,DATSET,MAXPW2,MINPW2
      REAL TOL,EPS
      LOGICAL TEXT
C
      COMMON /COMI/ LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2,
     & LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC,SLINE,OPCODE,
     & OPT1,OPT2,OPT3,EXTADR,FLINES,MAXRAM,LDNI,LDNO,LLINE,MXLINE,
     & FW,LDNC,TEXT,DATSET,TOL,EPS,MAXPW2,MINPW2
C
C
      CHARACTER  INFILE*80,OFILE*80,PROGN*20,TXT*20
      DIMENSION TXT(7)
C
      COMMON /COMC/ INFILE,OFILE,PROGN,TXT
C
C
      IF(LLINE+L2.GT.MXLINE) THEN
         CALL FF
         LLINE=2
      ENDIF
      LLINE= LLINE+L1
      RETURN
      END
      SUBROUTINE CALEXE(MEMORY)
      IMPLICIT LOGICAL(A-Z)
C
      INTEGER K,L,I,EXTAD1,IFAIL
      REAL MEMORY(*)
C
C
      INTEGER LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2
      INTEGER LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC
      INTEGER SLINE,OPCODE,OPT1,OPT2,OPT3,EXTADR,FLINES
C
      INTEGER LLINE,MXLINE,FW,LDNI,LDNO,LDNC
      INTEGER MAXRAM,DATSET,MAXPW2,MINPW2
      REAL TOL,EPS
      LOGICAL TEXT
C
      COMMON /COMI/ LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2,
     & LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC,SLINE,OPCODE,
     & OPT1,OPT2,OPT3,EXTADR,FLINES,MAXRAM,LDNI,LDNO,LLINE,MXLINE,
     & FW,LDNC,TEXT,DATSET,TOL,EPS,MAXPW2,MINPW2
C
C
      CHARACTER  INFILE*80,OFILE*80,PROGN*20,TXT*20
      DIMENSION TXT(7)
C
      COMMON /COMC/ INFILE,OFILE,PROGN,TXT
C
C
      IF(OPCODE.EQ.51) THEN
         EXTAD1= EXTADR+RA
         CALL F01AJF(LA,TOL,MEMORY(ADRA),LA,MEMORY(EXTADR),
     &               MEMORY(EXTAD1),MEMORY(ADRB),LA)
         CALL F02AMF(LA,EPS,MEMORY(EXTADR),MEMORY(EXTAD1),
     &               MEMORY(ADRB),LA,IFAIL)
         IF(IFAIL.EQ.1) THEN
            CALL ADV(3,3)
            WRITE(LDNO,9000)LA,RA,SLINE
            STOP
         ENDIF
         CALL CREATE(MEMORY(ADRC),LA,RA,0,IFAIL)
         K=ADRC
         L=EXTADR
         DO 100 I=1,LA
            MEMORY(K)= MEMORY(L)
            K=K+LA+1
            L=L+1
100      CONTINUE
      ENDIF
C
9000  FORMAT(/' SPEC: MATRIX[',I4,',',I4,'] NEEDED MORE THAN 30',
     & ' ITERATIONS TO ISOLATE ONE EIGENVALUE.'/,
     & ' (SOURCE LINE: ',I2,')')
      END
      SUBROUTINE CHOLFL(A,P,L)
      IMPLICIT LOGICAL(A-Z)
C
C     FILL UP CHOLESKY DECOMPOSED MATRIX
C
      INTEGER L,I,J
      REAL A(L,L),P(L)
C
      DO 100 I=1,L
         DO 100 J= I,L
            IF(I.EQ.J) THEN
               A(I,J)=1.0D0/P(I)
            ELSE
               A(I,J)= A(J,I)
               A(J,I)=0.0D0
            ENDIF
100   CONTINUE
      END
      SUBROUTINE CHS(A,L,R,B)
      IMPLICIT LOGICAL (A-Z)
C
C      ZWECK: VORZEICHENWECHSEL DER MATRIX A
C
C      PARAMETER:
C          A(L,R)    - REAL ARRAY    :  EINGABEMATRIX
C            L,R     - INTEGER       :  DIMENSION VON A U. B
C          B(L,R)    - REAL ARRAY    :  AUSGABEMATRIX
C
C
      INTEGER L,R,I
      REAL A(*),B(*)
      DO 1 I=1,L*R
         B(I)=-A(I)
1     CONTINUE
      RETURN
      END
      SUBROUTINE CLOSEA
C
      INTEGER LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2
      INTEGER LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC
      INTEGER SLINE,OPCODE,OPT1,OPT2,OPT3,EXTADR,FLINES
C
      INTEGER LLINE,MXLINE,FW,LDNI,LDNO,LDNC
      INTEGER MAXRAM,DATSET,MAXPW2,MINPW2
      REAL TOL,EPS
      LOGICAL TEXT
C
      COMMON /COMI/ LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2,
     & LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC,SLINE,OPCODE,
     & OPT1,OPT2,OPT3,EXTADR,FLINES,MAXRAM,LDNI,LDNO,LLINE,MXLINE,
     & FW,LDNC,TEXT,DATSET,TOL,EPS,MAXPW2,MINPW2
C
C
      CHARACTER  INFILE*80,OFILE*80,PROGN*20,TXT*20
      DIMENSION TXT(7)
C
      COMMON /COMC/ INFILE,OFILE,PROGN,TXT
C
      RETURN
      END
      SUBROUTINE CNORM(A,L,R,B)
      IMPLICIT LOGICAL(A-Z)
C
C     ZWECK: BILDE DIE SPALTENNORM VON A (MAX. SPALTENSUMME DER
C     BETRAEGE DER SPALTENELEMENTE VON A
C
      INTEGER L,R,I,J,K
      REAL A(*),B,SUM
C
      B=0.0D0
      K=1
      DO 100 I= 1,R
         SUM=0.0
         DO 200 J=1,L
            SUM= SUM+ ABS(A(K))
            K=K+1
200      CONTINUE
         IF(SUM.GT.B) B=SUM
100   CONTINUE
      END
      SUBROUTINE COPY(A,LA,RA,LA1,LA2,RA1,RA2,B,LB,RB,LB1,LB2,RB1,RB2,
     & IFAIL )
      IMPLICIT LOGICAL(A-Z)
C
C     ZWECK: SPEICHERE DIE MATRIX A ODER EINE SUBMATRIX VON A NACH
C            B ODER AN EINE BESTIMMTE STELLE VON B.
C
C     PARAMETER:  A(LA,RA)     AUSGANGSMATRIX         REAL
C                 B(LB,RB)     ZIELMATRIX             REAL
C                 LA,RA        DIM(A)                 INTEGER
C                 LB,RB        DIM(B)                 INTEGER
C                 LA1,LA2      ZEILENINTERVALL A      INTEGER
C                 RA1,RA2      SPALTENINTERVALL B     INTEGER
C                 LB1,LB2      ZEILENINTERVALL B      INTEGER
C                 RB1,RB2      SPALTENINTERVALL B     INTEGER
C
C     GENAUIGKEIT: EXAKT
C
      INTEGER LA,LB,RA,RB,LA1,LA2,RA1,RA2,LB1,LB2,RB1,RB2,I,J,L
      INTEGER IFAIL
      REAL A(LA,RA),B(LB,RB)
C
      IFAIL=0
      L=LB1
      DO 10 J=RA1,RA2
      DO 11 I=LA1,LA2
        B(LB1,RB1)=A(I,J)
        LB1=LB1+1
11       CONTINUE
      RB1=RB1+1
      LB1=L
10    CONTINUE
      RETURN
      END
      SUBROUTINE CREATE(A,L,R,OPT,IFAIL)
      IMPLICIT LOGICAL (A-Z)
C
C     ZWECK: SETZE FUER A:   EINHEITSMATRIX  (OPT=1)
C                            EINSMATRIX(VEKTOR)  (OPT=2)
C                            NULLMATRIX(VEKTOR)  (OPT=0)
C
C     FUER DEN FALL OPT=1 MUSS L=R SEIN.
C
C     PARAMETER     A(L,R)     AUSGABEMATRIX       REAL
C                   L,R        DIM (A)             INTEGER
C                   OPT        S.O.                INTEGER
C
C     GENAUIGKEIT: EXAKT
C
      INTEGER IMAX,L,R,OPT,IFAIL,I,J
      REAL A(L,R)
C
C     PARAMETERUEBERPRUEFUNG
C
      IFAIL=0
      IF(OPT.EQ.1.AND.L.NE.R) GOTO 1
      IF(OPT.NE.1.AND.OPT.NE.2.AND.OPT.NE.0)GOTO 1
C
C     NULLSETZEN (NICHT FUER OPT=2)
C
      IF(OPT.EQ.2) GOTO 2
      DO 10 J=1,R
            DO 10 I=1,L
10          A(I,J)=0.0
      IF(OPT.EQ.0)RETURN
C
C     EINHEITSMATRIX
C
      DO 11 I=1,L
11       A(I,I)=1.0
      RETURN
2     DO 12 J=1,R
            DO 12 I=1,L
12          A(I,J)=1.0
      RETURN
1     IFAIL=1
      RETURN
      END
      SUBROUTINE DIAG(A,L,R,B)
      IMPLICIT LOGICAL(A-Z)
C
C     ZWECK: KOPIERE DIE DIAGONALE AUS A IN MATRIX B
C
      INTEGER L,R,I,J,IFAIL
      REAL A(L,R),B(L,R)
C
      CALL CREATE(B,L,R,0,IFAIL)
      DO 100 I=1,L
         B(I,I)= A(I,I)
100   CONTINUE
      END
      SUBROUTINE DINV(A,B,L,R,IFAIL)
      IMPLICIT LOGICAL(A-Z)
C
C      ZWECK : BERECHNE DIE INVERSE DER DIAGONALEN VON A
C              UND KOPIERE SIE NACH B ( B NULLMATRIX)
C
C      PARAMETER
C      A       - REAL ARRAY(L,R)  :  EINGABEFELD
C      B       - REAL ARRAY(L,R)  :  AUSGABEFELD
C      L,R     - INTEGER          :  DIMENSION VON A,B  A.EQ.B
C      IFAIL   - INTEGER          :  WENN EIN DIAG. ELEMENT = 0,
C                                    DANN IST IFAIL = 1
C
C
      REAL  A(*),B(*)
      INTEGER L,R,I,IFAIL

      IFAIL=0
C
C---   NULLMATRIX B ERZEUGEN
C
      CALL CREATE(B,L,R,0,IFAIL)
      IF(IFAIL.NE.0)  RETURN
C
C---   INVERTIEREN
C
      DO 1 I=1,L*R,L+1
         IF(A(I).EQ.0.0)THEN
            IFAIL=1
            RETURN
         ENDIF
         B(I)=1.0 /A(I)
1     CONTINUE
      RETURN
      END
      SUBROUTINE EXECUTE(MEMORY)
      IMPLICIT LOGICAL(A-Z)
C
      INTEGER I,IFAIL
      REAL MEMORY(*)
C
      INTEGER LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2
      INTEGER LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC
      INTEGER SLINE,OPCODE,OPT1,OPT2,OPT3,EXTADR,FLINES
C
      INTEGER LLINE,MXLINE,FW,LDNI,LDNO,LDNC
      INTEGER MAXRAM,DATSET,MAXPW2,MINPW2
      REAL TOL,EPS
      LOGICAL TEXT
C
      COMMON /COMI/ LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2,
     & LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC,SLINE,OPCODE,
     & OPT1,OPT2,OPT3,EXTADR,FLINES,MAXRAM,LDNI,LDNO,LLINE,MXLINE,
     & FW,LDNC,TEXT,DATSET,TOL,EPS,MAXPW2,MINPW2
C
C
      CHARACTER  INFILE*80,OFILE*80,PROGN*20,TXT*20
      DIMENSION TXT(7)
C
      COMMON /COMC/ INFILE,OFILE,PROGN,TXT
C
C
C
C     INTERPRET CODE
      IF(OPCODE.NE.7) TEXT= .FALSE.
C
C
C     FUNCTION EXECUTE
C
      IF(OPCODE.GE.21) THEN
         CALL FUNCT(MEMORY)
C
C     MATRIX ADDITION
C
      ELSE IF(OPCODE.EQ.1) THEN
         CALL ADSUB(MEMORY(ADRA),MEMORY(ADRB),MEMORY(ADRC),LA,RA,
     &              LB,RB,0,IFAIL)
C
C     MATRIX SUBTRACTION
C
      ELSE IF (OPCODE.EQ.2) THEN
         CALL ADSUB(MEMORY(ADRA),MEMORY(ADRB),MEMORY(ADRC),LA,RA,
     &              LB,RB,1,IFAIL)
C
C     MATRIX MULTIPLICATION
C
      ELSE IF (OPCODE.EQ.3) THEN
         CALL MULT(MEMORY(ADRA),MEMORY(ADRB),MEMORY(ADRC),LA,RA,
     &             LB,RB,IFAIL)
C
C     MATRIX READ
C
      ELSE IF (OPCODE.EQ.4) THEN
         DATSET= DATSET+1
         CALL MREAD(LDNI,MEMORY(ADRA),LA,RA,OPT1,IFAIL)
         IF(IFAIL.EQ.-1) THEN
            CALL ADV(2,2)
            WRITE(LDNO,9000)DATSET
            STOP
         ELSE IF(IFAIL.EQ.-2) THEN
            CALL ADV(2,2)
            WRITE(LDNO,9010)DATSET
            STOP
         ELSE IF(IFAIL.EQ.-3) THEN
            CALL ADV(2,2)
            WRITE(LDNO,9020)DATSET
         ELSE
         ENDIF
C
C     MATRIX WRITE
C
      ELSE IF(OPCODE.EQ.5) THEN
         CALL MWRITE(MEMORY(ADRA),LA,RA,OPT1,OPT2,OPT3,FW,LDNO,IFAIL)
C
C     MATRIX CREATE
C
      ELSE IF(OPCODE.EQ.6) THEN
         CALL CREATE(MEMORY(ADRA),LA,RA,OPT1,IFAIL)
C
C     PRINT TEXT
C
      ELSE IF(OPCODE.EQ.7) THEN
         IF(.NOT.TEXT) THEN
            CALL ADV(1,1)
            WRITE(LDNO,9030)
            TEXT= .TRUE.
         ENDIF
         CALL ADV(1,1)
         WRITE(LDNO,9040)(TXT(I),I=1,FLINES)
C
C     LOAD LITERAL
C
      ELSE IF(OPCODE.EQ.8) THEN
         MEMORY(EXTADR)=OPT1
C
C     COPY MATRIX
C
      ELSE IF(OPCODE.EQ.9) THEN
         CALL COPY(MEMORY(ADRA),LA,RA,LA1,LA2,RA1,RA2,MEMORY(ADRB),
     &             LB,RB,LB1,LB2,RB1,RB2,IFAIL)
      ELSE
         IFAIL=99
      ENDIF
C
C     ILLEGAL CALL
C
      IF(IFAIL.EQ.1) THEN
         CALL ADV(3,3)
         WRITE(LDNO,9050)SLINE,OPCODE,FLINES,OPT1,OPT2,OPT3
         STOP
      ENDIF
C
9000  FORMAT(/' UNEXPECTED EOF IN DATA SECTION ',I3)
9010  FORMAT(/' TOO MANY ELEMENTS IN DATA SECTION ',I3)
9020  FORMAT(/' READ ERROR OR TOO FEW ELEMENTS IN DATA SECTION ',I3)
9030  FORMAT(1X)
9040  FORMAT(' ',7A)
9050  FORMAT(/' MATRIX INTERNAL ERROR (BAD FUNCTION CALL)'/
     &       ' SOURCE LINE: ',I3,' OPCODE: ',I2,' #LINES: ',I2,
     &       ' OPTIONS: ',3(I4,1X))
      RETURN
      END
      SUBROUTINE F01AJF(N,TOL,A,IA,D,E,Z,IZ)
      IMPLICIT LOGICAL(A-Z)
C
C
C
      INTEGER N,IA,IZ,I,J,L,K
      REAL TOL,A(IA,N),D(N),E(N),Z(IZ,N),F,G,H,H1
C
      DO 100 I=1,N
         DO 100 J=1,I
            Z(I,J)=A(I,J)
100   CONTINUE
C
      DO 110 I=N,2,-1
         L=I-2
         F=Z(I,I-1)
         G=0.0D0
         DO 120 K=1,L
            G=G+Z(I,K)*Z(I,K)
120      CONTINUE
         H=G+F*F
         IF(G.LE.TOL)THEN
            E(I)=F
            H=0
         ELSE
            L=L+1
            IF(F.GE.0.0D0) THEN
               G=-SQRT(H)
            ELSE
               G= SQRT(H)
            ENDIF
            E(I)=G
            H=H-F*G
            Z(I,I-1)=F-G
            F=0
            DO 130 J=1,L
               Z(J,I)= Z(I,J)/H
               G=0
               DO 140 K=1,J
                  G=G+Z(J,K)*Z(I,K)
140            CONTINUE
               DO 150 K=J+1,L
                  G=G+Z(K,J)*Z(I,K)
150            CONTINUE
               E(J)= G/H
               F=F+G*Z(J,I)
130         CONTINUE
            H1=F/(H+H)
            DO 160 J=1,L
               F=Z(I,J)
               G=E(J)-H1*F
               E(J)=G
               DO 170 K=1,J
                  Z(J,K)=Z(J,K)-F*E(K)-G*Z(I,K)
170            CONTINUE
160         CONTINUE
         ENDIF
         D(I)=H
110   CONTINUE
C
      D(1)=0.0D0
      E(1)=0.0D0
      DO 180 I=1,N
         L=I-1
         IF(D(I).NE.0.0D0) THEN
            DO 190 J=1,L
               G=0.0D0
               DO 200 K=1,L
                  G=G+Z(I,K)*Z(K,J)
200            CONTINUE
               DO 210 K=1,L
                  Z(K,J)=Z(K,J)-G*Z(K,I)
210            CONTINUE
190         CONTINUE
         ENDIF
         D(I)=Z(I,I)
         Z(I,I)=1.0D0
         DO 220 J=1,L
            Z(I,J)=0.0D0
            Z(J,I)=0.0D0
220      CONTINUE
180   CONTINUE
      END
      SUBROUTINE F01CKF(A,B,C,N,P,M,Z,IZ,OPT,IFAIL)
      IMPLICIT LOGICAL (A-Z)
C
C     MULTIPLIKATION  A:=B*C
C
C     PARAMETER:
C
C     A   -  /REAL ARRAY/ DIM(N,P)
C            ENTHAELT RESULTAT DER BERECHNUNG
C
C     B   -  /REAL ARRAY/ DIM(N,M)
C
C     C   -  /REAL ARRAY/ DIM(M,P)
C
C     N   -  /INTEGER/    ERSTE DIMENSION VON B
C
C     P   -  /INTEGER/    ZWEITE DIMENSION VON C
C
C     M   -  /INTEGER/
C
C     Z   -  /REAL ARRAY/ DIM(IZ)
C
C    IZ   -  /INTEGER/    =1
C
C    OPT  -  /INTEGER/    =1
C
C   IFAIL -  /INTEGER/    FEHLERPARAMETER
C
C
      INTEGER N,P,M,IZ,OPT,IFAIL
      INTEGER IR,IK,K,J,I,JI,IB
      REAL A(*),B(*),C(*),Z(IZ)
      DOUBLE PRECISION PROD
C
      IFAIL=0
      IF(OPT.NE.1) THEN
         IFAIL=5
      ELSE
         IR=0
         IK=-M
         DO 10 K=1,P
               IK=IK+M
               DO 10 J=1,N
                     IR=IR+1
                     JI=J-N
                     IB=IK
                     PROD= 0.0D0
                     DO 9 I=1,M
                          JI=JI+N
                             IB=IB+1
9                         PROD=PROD+DPROD(B(JI),C(IB))
10           A(IR)=SNGL(PROD)
      ENDIF
      RETURN
      END
      SUBROUTINE F02AMF(N,EPS,D,E,V,IV,IFAIL)
      IMPLICIT LOGICAL(A-Z)
C
      INTEGER N,IV,IFAIL,I,L,J,M,K
      REAL D(N),E(N),V(IV,N),EPS,B,F,Z9,P,C,S,H,G,R
C
      DO 100 I=2,N
         E(I-1)= E(I)
100   CONTINUE
C
      E(N)=0
      B=0
      F=0
      IFAIL=0
C
      DO 120 L=1,N
         J=0
         H=EPS*(ABS(D(L))+ABS(E(L)))
         IF(B.LT.H) B=H
         DO 130 M=L,N
            IF(ABS(E(M)).LE.B) GOTO 140
130      CONTINUE
140      CONTINUE
         IF(M.NE.L) THEN
1000        IF(J.EQ.30) THEN
               IFAIL=1
               RETURN
            ENDIF
            J=J+1
            G=D(L)
            P=(D(L+1)-G)/(2.0D0*E(L))
            R=SQRT(P*P+1)
            IF(P.LT.0.0D0) THEN
               Z9=P-R
            ELSE
               Z9=P+R
            ENDIF
            D(L)= E(L)/Z9
            H=G-D(L)
            DO 150 I=L+1,N
               D(I)=D(I)-H
150         CONTINUE
            F=F+H
            P=D(M)
            C=1.0D0
            S=0.0D0
            DO 160 I=M-1,L,-1
               G=C*E(I)
               H=C*P
               IF(ABS(P).GE.ABS(E(I))) THEN
                  C=E(I)/P
                  R=SQRT(C*C+1)
                  E(I+1)=S*P*R
                  S=C/R
                  C=1/R
               ELSE
                  C=P/E(I)
                  R=SQRT(C*C+1)
                  E(I+1)=S*E(I)*R
                  S=1/R
                  C=C/R
               ENDIF
               P=C*D(I)-S*G
               D(I+1)=H+S*(C*G+S*D(I))
               DO 170 K=1,N
                  H=V(K,I+1)
                  V(K,I+1)=S*V(K,I)+C*H
                  V(K,I)=C*V(K,I)-S*H
170            CONTINUE
160         CONTINUE
            E(L)=S*P
            D(L)=C*P
            IF(ABS(E(L)).GT.B) GOTO 1000
         ENDIF
         D(L)=D(L)+F
120   CONTINUE
C
      DO 180 I=1,N
         K=I
         P=D(I)
         DO 190 J=I+1,N
            IF(D(J).LT.P) THEN
               K=J
               P=D(J)
            ENDIF
190      CONTINUE
         IF(K.NE.I) THEN
            D(K)=D(I)
            D(I)=P
            DO 200 J=1,N
               P=V(J,I)
               V(J,I)=V(J,K)
               V(J,K)=P
200         CONTINUE
         ENDIF
180   CONTINUE
      END
      SUBROUTINE F03AEF(N,A,IA,P,D1,ID,IFAIL)
      IMPLICIT LOGICAL(A-Z)
C
C     CHOLESKY DECOMPOSITION
C
      INTEGER N,IA,ID,IFAIL,I,J,K
      REAL A(IA,N),P(N)
      DOUBLE PRECISION D1,X
C
      IFAIL=0
      D1=1.0D0
      ID=0
      DO 100 I=1,N
         DO 100 J=I,N
            X=A(I,J)
            DO 110 K=I-1,1,-1
               X=X-DPROD(A(J,K),A(I,K))
110         CONTINUE
            IF(I.NE.J) THEN
               A(J,I)=X*P(I)
            ELSE
               D1=D1*X
               IF(X.EQ.0.0D0) THEN
                  IFAIL=1
                  RETURN
               ENDIF
120            IF(ABS(D1).GE.1.0D0)THEN
                  D1=D1*0.0625D0
                  ID=ID+4
                  GOTO 120
               ENDIF
130            IF(ABS(D1).LT.0.0625D0) THEN
                  D1=D1*16.0D0
                  ID=ID-4
                  GOTO 130
               ENDIF
               IF(X.LT.0.0D0) THEN
                  IFAIL=1
                  RETURN
               ENDIF
               P(I)=1.0D0/DSQRT(X)
            ENDIF
100   CONTINUE
      END
       SUBROUTINE F03AFF(N,EPS,A,IA,D1,ID,P,IFAIL)
       IMPLICIT LOGICAL(A-Z)
C
C
C
       INTEGER N,IFAIL,ID,I,J,K,L,IA
       REAL A(IA,N),D1,P(N),Y,X,EPS
C
       DO 100 I=1,N
          Y=0.0D0
          DO 110 J=1,N
             Y=Y+A(I,J)*A(I,J)
110       CONTINUE
          P(I)= 1.0D0/SQRT(Y)
100    CONTINUE
C
       IFAIL=0
       D1=1.0D0
       ID=0
       DO 120 K=1,N
          L=K
          X=0.0D0
          DO 130 I=K,N
             Y=-A(I,K)
             DO 140 J=1,K-1
                Y=Y+A(I,J)*A(J,K)
140          CONTINUE
             A(I,K)=-Y
             Y=ABS(Y*P(I))
             IF (Y.GT.X) THEN
                X=Y
                L=I
             ENDIF
130       CONTINUE
          IF(L.NE.K) THEN
             D1=-D1
             DO 150 J=1,N
                Y=A(K,J)
                A(K,J)=A(L,J)
                A(L,J)=Y
150          CONTINUE
             P(L)=P(K)
          ENDIF
          P(K)=L
          D1=D1*A(K,K)
          IF(X.LT.(8.0D0*EPS)) THEN
             IFAIL=1
             RETURN
          ENDIF
160       IF(ABS(D1).GE.1.0D0) THEN
             ID=ID+4
             D1=D1*0.0625D0
             GOTO 160
          ENDIF
170       IF(ABS(D1).LT.0.0625D0) THEN
             ID=ID-4
             D1=D1*16.0D0
             GOTO 170
          ENDIF
          X=-1.0D0/A(K,K)
          DO 180 J=K+1,N
             Y=-A(K,J)
             DO 190 I=1,K-1
                Y=Y+A(K,I)*A(I,J)
190          CONTINUE
             A(K,J)=X*Y
180       CONTINUE
120   CONTINUE
      END
      SUBROUTINE F04AJF(N,IR,A,IA,P,B,IB)
      IMPLICIT LOGICAL(A-Z)
C
C     INVERT CHOLESKY DECOMPOSED MATRIX
C
      INTEGER N,I,J,K,IR,IA,IB
      REAL A(IA,N),P(N),B(IB,IR)
      REAL T
      DOUBLE PRECISION X
C
      DO 100 I=1,N
         IF(P(I).NE.I) THEN
            DO 110 K=1,IR
               T=B(I,K)
               B(I,K)=B(INT(P(I)),K)
               B(INT(P(I)),K)=T
110         CONTINUE
         ENDIF
100   CONTINUE
      DO 120 K=1,IR
         DO 130 I=1,N
            X=B(I,K)
            DO 140 J=1,I-1
               X=X+DPROD(A(I,J),B(J,K))
140         CONTINUE
            B(I,K)=-X/A(I,I)
130      CONTINUE
         DO 150 I=N,1,-1
            X=B(I,K)
            DO 160 J=I+1,N
               X=X+DPROD(A(I,J),B(J,K))
160         CONTINUE
            B(I,K)=-X
150      CONTINUE
120   CONTINUE
      END
      SUBROUTINE FF
C
      INTEGER LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2
      INTEGER LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC
      INTEGER SLINE,OPCODE,OPT1,OPT2,OPT3,EXTADR,FLINES
C
      INTEGER LLINE,MXLINE,FW,LDNI,LDNO,LDNC
      INTEGER MAXRAM,DATSET,MAXPW2,MINPW2
      REAL TOL,EPS
      LOGICAL TEXT
C
      COMMON /COMI/ LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2,
     & LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC,SLINE,OPCODE,
     & OPT1,OPT2,OPT3,EXTADR,FLINES,MAXRAM,LDNI,LDNO,LLINE,MXLINE,
     & FW,LDNC,TEXT,DATSET,TOL,EPS,MAXPW2,MINPW2
C
C
      CHARACTER  INFILE*80,OFILE*80,PROGN*20,TXT*20
      DIMENSION TXT(7)
C
      COMMON /COMC/ INFILE,OFILE,PROGN,TXT
C
C
      WRITE(LDNO,9000) '1'
9000  FORMAT(A)
      RETURN
      END
      SUBROUTINE FINISH
      IMPLICIT LOGICAL(A-Z)
C
      INTEGER LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2
      INTEGER LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC
      INTEGER SLINE,OPCODE,OPT1,OPT2,OPT3,EXTADR,FLINES
C
      INTEGER LLINE,MXLINE,FW,LDNI,LDNO,LDNC
      INTEGER MAXRAM,DATSET,MAXPW2,MINPW2
      REAL TOL,EPS
      LOGICAL TEXT
C
      COMMON /COMI/ LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2,
     & LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC,SLINE,OPCODE,
     & OPT1,OPT2,OPT3,EXTADR,FLINES,MAXRAM,LDNI,LDNO,LLINE,MXLINE,
     & FW,LDNC,TEXT,DATSET,TOL,EPS,MAXPW2,MINPW2
C
C
      CHARACTER  INFILE*80,OFILE*80,PROGN*20,TXT*20
      DIMENSION TXT(7)
C
      COMMON /COMC/ INFILE,OFILE,PROGN,TXT
C
C
C     CLOSE ALL FILES
C
      CALL CLOSEA
C
      CALL ADV(1,1)
      WRITE(LDNO,9000)PROGN,MAXRAM
9000  FORMAT(' END  ',A,', STORAGE ALLOCATED: ',I8,' WORDS')
      RETURN
      END
      SUBROUTINE FUNCT(MEMORY)
      IMPLICIT LOGICAL(A-Z)
C
      INTEGER IFAIL,ID,EXTAD1,EXTAD2,I,IR,K
      REAL D1,NM,CHECK,MEMORY(*),NMINP,NMOUT
C
      INTEGER LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2
      INTEGER LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC
      INTEGER SLINE,OPCODE,OPT1,OPT2,OPT3,EXTADR,FLINES
C
      INTEGER LLINE,MXLINE,FW,LDNI,LDNO,LDNC
      INTEGER MAXRAM,DATSET,MAXPW2,MINPW2
      REAL TOL,EPS
      LOGICAL TEXT
C
      COMMON /COMI/ LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2,
     & LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC,SLINE,OPCODE,
     & OPT1,OPT2,OPT3,EXTADR,FLINES,MAXRAM,LDNI,LDNO,LLINE,MXLINE,
     & FW,LDNC,TEXT,DATSET,TOL,EPS,MAXPW2,MINPW2
C
C
      CHARACTER  INFILE*80,OFILE*80,PROGN*20,TXT*20
      DIMENSION TXT(7)
C
      COMMON /COMC/ INFILE,OFILE,PROGN,TXT
C
C
      IFAIL=0
      IF(OPCODE.GE.51) THEN
         CALL CALEXE(MEMORY)
C
C     CHANGE SIGN
C
      ELSE IF(OPCODE.EQ.21) THEN
         CALL CHS(MEMORY(ADRA),LA,RA,MEMORY(ADRB))
C
C     INVERSE   (SYM. POS. DEF)
C
      ELSE IF(OPCODE.EQ.22) THEN
         CALL MOVE(MEMORY(ADRA),MEMORY(ADRB),LA*RA)
         CALL INV(LA,MEMORY(ADRB),MEMORY(EXTADR),
     &         D1,ID,IFAIL)
         IF(IFAIL.EQ.1) THEN
            CALL ADV(2,2)
            WRITE(LDNO,9000)'INV', LA,RA,SLINE
            STOP
         ENDIF
         IF((ID.GT.MAXPW2).OR.(ID.LT.MINPW2)) THEN
            CALL ADV(2,2)
            WRITE(LDNO,9050) 'INV',LA,RA,SLINE
            STOP
         ENDIF
         CALL ADV(2,2)
         WRITE(LDNO,9010)'INV',LA,RA,D1*2.0D0**ID,SLINE
         CALL NORM(MEMORY(ADRA),LA,RA,NMINP)
         CALL NORM(MEMORY(ADRB),LA,RA,NMOUT)
         CALL ADV(2,2)
         WRITE(LDNO,9020)'INV',LA,RA,NMINP*NMOUT,SLINE
C
C     INVERT QUADRATIC MATRIX
C
      ELSE IF(OPCODE.EQ.23) THEN
         CALL MOVE(MEMORY(ADRA),MEMORY(EXTADR),LA*RA)
         EXTAD1= EXTADR+LA*RA
         CALL F03AFF(LA,EPS,MEMORY(EXTADR),LA,D1,ID,MEMORY(EXTAD1),
     &               IFAIL)
        IF(IFAIL.EQ.1) THEN
           CALL ADV(2,2)
           WRITE(LDNO,9000)'INQ', LA,RA,SLINE
           STOP
        ENDIF
        CALL CREATE(MEMORY(ADRB),LA,RA,1,IFAIL)
        CALL F04AJF(LA,LA,MEMORY(EXTADR),LA,MEMORY(EXTAD1),
     &              MEMORY(ADRB),LA)
         IF((ID.GT.MAXPW2).OR.(ID.LT.MINPW2)) THEN
            CALL ADV(2,2)
            WRITE(LDNO,9050) 'INQ',LA,RA,SLINE
            STOP
         ENDIF
         CALL ADV(2,2)
         WRITE(LDNO,9010)'INQ',LA,RA,D1*2.0D0**ID,SLINE
         CALL NORM(MEMORY(ADRA),LA,RA,NMINP)
         CALL NORM(MEMORY(ADRB),LA,RA,NMOUT)
         CALL ADV(2,2)
         WRITE(LDNO,9020)'INQ',LA,RA,NMINP*NMOUT,SLINE
C
C     INVERT DIAGONAL MATRIX
C
      ELSE IF(OPCODE.EQ.24) THEN
         CALL DINV(MEMORY(ADRA),MEMORY(ADRB),LA,RA,IFAIL)
         IF(IFAIL.EQ.1) THEN
            CALL ADV(2,2)
            WRITE(LDNO,9000)'DINV',LA,RA,SLINE
            STOP
         ENDIF
C
C     CNORM
C
      ELSE IF(OPCODE.EQ.25) THEN
         CALL CNORM(MEMORY(ADRA),LA,RA,MEMORY(ADRB))
C
C     FNORM
C
      ELSE IF(OPCODE.EQ.26) THEN
         CALL NORM(MEMORY(ADRA),LA,RA,MEMORY(ADRB))
C
C     RNORM
C
      ELSE IF(OPCODE.EQ.27)THEN
         CALL RNORM(MEMORY(ADRA),LA,RA,MEMORY(ADRB))
C
C     DET
C
      ELSE IF(OPCODE.EQ.28) THEN
         CALL MOVE(MEMORY(ADRA),MEMORY(EXTADR),LA*RA)
         EXTAD1= EXTADR+LA*RA
         CALL F03AFF(LA,EPS,MEMORY(EXTADR),LA,D1,ID,MEMORY(EXTAD1),
     &               IFAIL)
         IF(IFAIL.EQ.1)THEN
            CALL ADV(2,2)
            WRITE(LDNO,9000) 'DET',LA,RA,SLINE
            STOP
         ENDIF
         MEMORY(ADRB)= D1*2.0D0**ID
C
C     RSUM
C
      ELSE IF(OPCODE.EQ.29) THEN
         CALL ZSUM(MEMORY(ADRA),LA,RA,MEMORY(ADRB))
C
C     CSUM
C
      ELSE IF(OPCODE.EQ.30) THEN
         CALL SSUM(MEMORY(ADRA),LA,RA,MEMORY(ADRB))
C
C     TRN
C
      ELSE IF(OPCODE.EQ.31) THEN
         CALL TRANS(MEMORY(ADRA),LA,RA,MEMORY(ADRB))
C
C     PSEUDO INVERSE
C
      ELSE IF(OPCODE.EQ.32) THEN
         CALL NORM(MEMORY(ADRA),LA,RA,NM)
         IF(NM.LT.EPS) THEN
            CALL ADV(2,2)
            WRITE(LDNO,9080)LA,RA,SLINE
            STOP
         ENDIF
         CHECK=(NM/FLOAT(LA*LA))/10000.0D0
         EXTAD1= EXTADR+RA
         EXTAD2= EXTAD1+RA
         CALL F01AJF(LA,TOL,MEMORY(ADRA),LA,MEMORY(EXTADR),
     &               MEMORY(EXTAD1),MEMORY(EXTAD2),LA)
         CALL F02AMF(LA,EPS,MEMORY(EXTADR),MEMORY(EXTAD1),
     &               MEMORY(EXTAD2),LA,IFAIL)
         IF(IFAIL.EQ.1) THEN
            CALL ADV(3,3)
            WRITE(LDNO,9070)LA,RA,SLINE
            STOP
         ENDIF
         IR=0
         K=EXTADR
         DO 100 I=1,LA
             IF(ABS(MEMORY(K)).GT.CHECK) GOTO 110
             IR=IR+1
             K=K+1
100      CONTINUE
110      CALL ADV(2,2)
         WRITE(LDNO,9090)LA,RA,IR,SLINE
         CALL PSINV(MEMORY(EXTADR),MEMORY(EXTAD2),MEMORY(ADRB),
     &              LA,IR)
         CALL NORM(MEMORY(ADRA),LA,RA,NMINP)
         CALL NORM(MEMORY(ADRB),LA,RA,NMOUT)
         CALL ADV(2,2)
         WRITE(LDNO,9020)'PSINV',LA,RA,NMINP*NMOUT,SLINE
C
C     DIAGONAL
C
      ELSE IF(OPCODE.EQ.33) THEN
         CALL DIAG(MEMORY(ADRA),LA,RA,MEMORY(ADRB))
C
C     CHOL
C
      ELSE IF(OPCODE.EQ.34) THEN
         CALL MOVE(MEMORY(ADRA),MEMORY(ADRB),LA*RA)
         CALL F03AEF(LA,MEMORY(ADRB),LA,MEMORY(EXTADR),D1,ID,
     &               IFAIL)
         IF(IFAIL.EQ.1)THEN
            CALL ADV(2,2)
            WRITE(LDNO,9000)'CHOL', LA,RA,SLINE
            STOP
         ENDIF
         CALL CHOLFL(MEMORY(ADRB),MEMORY(EXTADR),LA)
C
C     SPUR
C
      ELSE IF(OPCODE.EQ.35) THEN
         CALL SPUR(MEMORY(ADRA),LA,RA,MEMORY(ADRB))
      ELSE
        STOP 'FUNCT: ILLEGAL OPCODE'
      ENDIF
C
9000  FORMAT(/' ',A,': MATRIX[',I4,',',I4,'] IS SINGULAR.  ',
     & '(SOURCE LINE: ',I2,')')
9010  FORMAT(/' ',A,':      DETERMINANT OF MATRIX[',I4,',',I4,
     & '] = ',G12.5,' (SOURCE LINE: ',I2,')')
9020  FORMAT(/' ',A,': CONDITION NUMBER OF MATRIX[',I4,',',I4,
     & '] = ',G12.5,' (SOURCE LINE: ',I2,')')
9050  FORMAT(/' ',A,': THE DETERMINANT OF MATRIX[',I4,',',I4,'] ',
     & 'IS OUT OF RANGE.  (SOURCE LINE: ',I2,')')
9070  FORMAT(/' PSINV: MATRIX[',I4,',',I4,'] NEEDED MORE THAN 30',
     & ' ITERATIONS TO ISOLATE ONE EIGENVALUE.'/,
     & ' (SOURCE LINE: ',I2,')')
9080  FORMAT(/' PSINV: MATRIX[',I4,',',I4,'] IS ZERO MATRIX')
9090  FORMAT(/' PSINV: RANK DEFECT OF MATRIX[',I4,',',I4,'] = ',
     & I4,' (SOURCE LINE: ',I2,')')
      RETURN
      END
      SUBROUTINE HEADER
      IMPLICIT LOGICAL(A-Z)
C
C     SUBROUTINE PRINTS HEADER ON LDNO
C
      INTEGER LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2
      INTEGER LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC
      INTEGER SLINE,OPCODE,OPT1,OPT2,OPT3,EXTADR,FLINES
C
      INTEGER LLINE,MXLINE,FW,LDNI,LDNO,LDNC
      INTEGER MAXRAM,DATSET,MAXPW2,MINPW2
      REAL TOL,EPS
      LOGICAL TEXT
C
      COMMON /COMI/ LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2,
     & LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC,SLINE,OPCODE,
     & OPT1,OPT2,OPT3,EXTADR,FLINES,MAXRAM,LDNI,LDNO,LLINE,MXLINE,
     & FW,LDNC,TEXT,DATSET,TOL,EPS,MAXPW2,MINPW2
C
C
      CHARACTER  INFILE*80,OFILE*80,PROGN*20,TXT*20,DATE*10, TIME*10
      DIMENSION TXT(7)
C
      COMMON /COMC/ INFILE,OFILE,PROGN,TXT
C
C
      CALL  FF
      WRITE(LDNO,9000) DATE(),TIME()
C
      LLINE=6
9000  FORMAT(/' MATRIX RUNTIME V1.0 (CDC NOS)         ',15X,10A,' ',10A,
     & ' (C) COPYRIGHT  J. SIEBOLD  1986'/)
      RETURN
      END
      SUBROUTINE INIT(FLEN,FWIDTH,LFNI,LFNO,LFNC)
      IMPLICIT LOGICAL(A-Z)
C
      INTEGER FLEN,FWIDTH,LFNI,LFNO,IOS,LFNC,IMAX
      INTEGER X02BCF,X02BDF
      REAL X02AAF,X02ABF,X
C
      INTEGER LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2
      INTEGER LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC
      INTEGER SLINE,OPCODE,OPT1,OPT2,OPT3,EXTADR,FLINES
C
      INTEGER LLINE,MXLINE,FW,LDNI,LDNO,LDNC
      INTEGER MAXRAM,DATSET,MAXPW2,MINPW2
      REAL TOL,EPS
      LOGICAL TEXT
C
      COMMON /COMI/ LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2,
     & LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC,SLINE,OPCODE,
     & OPT1,OPT2,OPT3,EXTADR,FLINES,MAXRAM,LDNI,LDNO,LLINE,MXLINE,
     & FW,LDNC,TEXT,DATSET,TOL,EPS,MAXPW2,MINPW2
C
C
      CHARACTER  INFILE*80,OFILE*80,PROGN*20,TXT*20
      DIMENSION TXT(7)
C
      COMMON /COMC/ INFILE,OFILE,PROGN,TXT
C
C
      LDNI= LFNI
      LDNO= LFNO
      LLINE=0
      DATSET=0
      MXLINE= FLEN
      FW= FWIDTH
      LDNC= LFNC
      TEXT= .FALSE.
      TOL= X02ABF(X)/X02AAF(X)
      EPS= X02AAF(X)
      MAXPW2= X02BCF(X)
      MINPW2= X02BDF(X)
C
C     OPEN INPUT/OUTPUT FILE
C
      CALL IOPEN
C
C     OPEN CODE FILE
C
      OPEN(LDNC,FILE='LOGO',STATUS='OLD',IOSTAT=IOS)
      IF(IOS.NE.0) THEN
         CALL ADV(1,1)
         WRITE(LDNO,9000)IOS
         STOP
      ENDIF
      REWIND(LDNC)
C
C     READ PROGRAM NAME AND CHECK SIZE
C
      READ(LDNC,8000)PROGN,IMAX
      MAXRAM= IMAX
C
8000  FORMAT(A20,1X,I10)
9000  FORMAT(' MATEXE: ERROR ACCESSING FILE LOGO   IOSTAT= ',I5)
      END
       SUBROUTINE INV(LA,A,P,D1,D2,IFAIL)
       IMPLICIT LOGICAL(A-Z)
C
       INTEGER LA,I,J,K,IFAIL,D2
       REAL A(LA,LA),P(LA),S,D1
C
      CALL F03AEF(LA,A,LA,P,D1,D2,IFAIL)
      IF(IFAIL.NE.0) RETURN
C
      DO 100 I=LA,1,-1
         DO 100 J=I,1,-1
            IF (I.EQ.J) THEN
               S=P(I)
            ELSE
               S=0.0D0
            ENDIF
            DO 110 K=J+1,LA
               IF (I.GT.K) THEN
                  S=S-A(K,J)*A(K,I)
               ELSE
                  S=S-A(K,J)*A(I,K)
               ENDIF
110         CONTINUE
            A(J,I)=S*P(J)
100   CONTINUE
      DO 120 I=1,LA
         DO 120 J=1,I-1
            A(I,J)=A(J,I)
120   CONTINUE
      END
      SUBROUTINE IOPEN
C
      INTEGER LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2
      INTEGER LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC
      INTEGER SLINE,OPCODE,OPT1,OPT2,OPT3,EXTADR,FLINES
C
      INTEGER LLINE,MXLINE,FW,LDNI,LDNO,LDNC
      INTEGER MAXRAM,DATSET,MAXPW2,MINPW2
      REAL TOL,EPS
      LOGICAL TEXT
C
      COMMON /COMI/ LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2,
     & LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC,SLINE,OPCODE,
     & OPT1,OPT2,OPT3,EXTADR,FLINES,MAXRAM,LDNI,LDNO,LLINE,MXLINE,
     & FW,LDNC,TEXT,DATSET,TOL,EPS,MAXPW2,MINPW2
C
C
      CHARACTER  INFILE*80,OFILE*80,PROGN*20,TXT*20
      DIMENSION TXT(7)
C
      COMMON /COMC/ INFILE,OFILE,PROGN,TXT
      OPEN(LDNI,FILE='INPUT')
      OPEN(LDNO,FILE='OUTPUT')
C
      RETURN
      END
      SUBROUTINE MOVE(A,B,I)
      IMPLICIT LOGICAL(A-Z)
C
C     MOVE ARRAY A TO ARRAY B
C
      INTEGER I,K
      REAL A(*),B(*)
C
      DO 100 K=1,I
         B(K)=A(K)
100   CONTINUE
      END
      SUBROUTINE MREAD(LFNI,A,L,R,ITYP,IFAIL)
      IMPLICIT LOGICAL (A-Z)
C
C
C     UNTERPROGRAMM ZUM LISTENGESTEUERTEN EINLESEN VON (SUB)MATRITZEN.
C
C
C
C     EINGABEPARAMETER:
C     BEDEUTUNG DER PARAMETER
C
C     A          REAL ARRAY(L,R) DAS EINGELESEN WERDEN SOLL
C     L,R      INTEGER; DIMENSION VON A.
C     ITYP     INTEGER: =0  "NORMALE" MATRIX
C                       =1  SYMMETRISCHE MATRIX
C                       =2  DIAGONALMATRIX
C     LDNI     INTEGER  LOGICAL NUMBER OF INPUT FILE
C
C
C     AUSGABEPARAMETER
C     IFAIL    INTEGER   =-1  ZU WENIG ELEMENTE IN DER ENTSPRECHENDEN
C                             SEKTION (UNEXPECTED EOF)
C                        =-2  ZU VIELE ELEMENTE IN DER ENTSPRECHENDEN
C                             SEKTION  (/ENDMAT NOT FOUND)
C                        =-3  READ ERROR
C                        = 0  ANZAHL DER MATRIXELEMENTE KORREKT
C                        = 1  FEHLERHAFTER AUFRUFPARAMETER
C
C
C     DATENFORMAT
C     JEDE MATRIX BILDET EINE SEKTION ,D.H. DIE MATRITZEN SIND UNTER
C     EINANDER ODER VON ANDEREN DATEN DURCH /ENDMAT ZEILEN ZU TRENNEN.
C     DIE ELEMENTE SIND GRUNDSAETZLICH ZEILENWEISE EINZUGEBEN.
C     SIE MUESSEN IN EINEM GUELTIGEN FORTRAN FORMAT ABGELOCHT,
C     UND VONEINANDER DURCH TRENNZEICHEN GETRENNT SEIN.
C     ALS TRENNZEICHEN GELTEN: EIN ODER MEHRERE LEERZEICHEN,
C     ENDE EINER LOCHKARTE. EINE 0 KANN NICHT DURCH BLANKS DAR-
C     GESTELLT WERDEN.
C
C     FUER ITYP=1(SYMMETRISCHE MATRIX) BRAUCHT NUR DAS OBERE DREI-
C     ECK EINGEGEBEN ZU WERDEN, DIE ERGAENZUNG ERFOLGT IM UNTERPRO-
C     GRAMM.
C
C
      CHARACTER FORM*1,ENDMAT*20
      INTEGER L,R,ITYP,IFAIL,J,K,I,LFNI
      REAL  A(L,R)
C
C     PRUEFEN DER EINGABEPARAMETER
C
      IFAIL=0
      IF ((ITYP.GT.0).AND.(L.NE.R)) THEN
         IFAIL=1
         RETURN
      ENDIF
C
C     NULLSETZEN DER MATRIX
C
      DO 1 J=1,R
      DO1  I=1,L
1     A(I,J)=0.0D0
C
      IF (ITYP.EQ.0) THEN
C
C        EINLESEN EINER NORMALEN MATRIX
C
         READ(LFNI,*,END=98,ERR=99)((A(J,K),K=1,R),J=1,L)
      ELSE IF (ITYP.EQ.1) THEN
C
C        EINLESEN EINER SYMMETRISCHEN MATRIX
C
         READ(LFNI,*,END=98,ERR=99)((A(I,J),J=I,R),I=1,L)
         DO 7 I=1,L
           DO 7 J=1,R
             A(J,I)=A(I,J)
7        CONTINUE
      ELSE
C
C        EINLESEN EINER DIGONALMATRIX
C
         READ(LFNI,*,END=98,ERR=99)(A(I,I),I=1,R)
      ENDIF
C
      READ(LFNI,1000,END=98) ENDMAT
      IF (ENDMAT(1:7).NE.'/ENDMAT') IFAIL=-2
      RETURN
98    IFAIL=-1
      RETURN
99    IFAIL=-3
      RETURN
1000  FORMAT(A20)
      END
      SUBROUTINE MULT(A,B,C,LA,RA,LB,RB,IFAIL)
      IMPLICIT LOGICAL (A-Z)
C
C     ROUTINE BERECHNET C:=A*B.  WENN A SKALAR,WIRD B SKALAR MULTI-
C     PLIZIERT.
C
C     PARAMETER:     A(LA,RA)          MATRIX A      REAL
C                    B(LB,RB)          MATRIX B      REAL
C                    C(LA,RB)          ERGIBTMATRIX  REAL
C                    LA,RA             DIM(A)        INTEGER
C                    LB,RB             DIM(B)        INTEGER
C
C     GENAUIGKEIT:       MATRIXMULTIPLIKATION: DOPPELTGENAUE AKKU-
C                        MULATION DER PRODUKTSUMMEN.
C                        SKALARMULTIPLIKATION: EINFACHGENAUE ARITH-
C                        METIK.
C
      INTEGER LA,RA,LB,RB,IR,IK,K,IB,IFAIL,I,J,JI,IZ,OPT
      REAL A(*),B(*),C(*),SCAL,DPROD,DUMMY(1)
C
      IFAIL=0
      IF(LA.EQ.1.AND.RA.EQ.1) THEN
           IR=LB*RB
           SCAL=A(1)
           DO 1 I=1,IR
1          C(I)=B(I)*SCAL
           RETURN
      ELSE IF(LB.EQ.1.AND.RB.EQ.1) THEN
          IR= RA*LA
          SCAL = B(1)
          DO 3 I=1,IR
3         C(I)=A(I)*SCAL
          RETURN
      ELSE
          IZ=1
          OPT=1
          CALL F01CKF(C,A,B,LA,RB,RA,DUMMY,IZ,OPT,IFAIL)
      ENDIF
      END
       SUBROUTINE MWRITE(A,LL,RR,IFORM,ITYP,IANZ,FORMW,IAUS,IFAIL)
       IMPLICIT LOGICAL(A-Z)
C
C      ZWECK FORMATIERTER AUSDRUCK DER MATRIX A
C
C      PARAMETER
C      =========
C
C      A  - REAL ARRAY DER DIMENSION(L,R)
C
C      L,R - INTEGER
C          L,R SIND DIE DIMENSIONEN VON A
C
C      IFORM - INTEGER
C          ENTHAELT   0  : AUSGABE IM FTN E- FORMAT
C                     1  :                F- FORMAT
C                     2  :                G- FORMAT
C
C      ITYP - INTEGER
C          =0  : AUSDRUCK EINER NORMALEN MATRIX
C          =1  :                SYMMETRISCHEN MATRIX
C          =2  :                DIAGONALMATRIX
C          =3  : AUSDRUCK EINER TRANSPONIERTEN NORMALEN MATRIX
C
C      IANZ - INTEGER
C          ANZAHL DER NACHKOMMASTELLEN IM F- FORMAT.
C          DIE LAENGE DER E-, G- FORMATE BETRAEGT IANZ+6
C
C      IAUS - INTEGER
C          LOG NR DER OUTPUT - DATEI
C
C      FORMW - INTEGER
C          ANZAHL DER SPALTEN DES AUSGABEFORMULARS
C
C      IFAIL - INTEGER
C          ENTHAELT 0 WENN KEIN FEHLER BEI PARAMETERUEBERPRUEFUNG
C
C
C      FEHLERMELDUNGEN:
C      ===============
C
C      IFAIL=
C        1:   IFORM ENTHAELT NICHT 0   OD. 1   OD. 2
C        2:   ITYP UNGLEICH 0 OD. 1 OD. 2
C        3:   IANZ KLEINER 1 ODER GROESSER 14
C        4:   IAUS KLEINER 0 ODER GROESSER 99
C        5:   ITYP=1 ODER 2 UND L UNGLEICH R
C
C
       INTEGER L,R,ITYP,IANZ,IFAIL,I,J,K,ILANG,TAB,IFORM,LL,RR
       INTEGER IAUS,IEND,IOFT,IOFT2,NUMDIG,ANZDIG,FORMW
       LOGICAL TRANS
       REAL   A(LL,RR)
       CHARACTER FORM*1,FORMPR*20,ZAHL2*2,ZAHL3*3
       DATA FORMPR/'(  1X,10(F10.10,1X))'/
C
C---   PARAMETER UEBERPRUEFEN
C
       IFAIL=0
       IF(IFORM.NE.0.AND.IFORM.NE.1.AND.IFORM.NE.2)IFAIL=1
       IF(ITYP.LT.0.OR.ITYP.GT.3)IFAIL=2
       IF(IANZ.LT.1.OR.IANZ.GT.14)IFAIL=3
       IF(IAUS.LT.0.OR.IAUS.GT.99)IFAIL=4
       IF((ITYP.EQ.1.OR.ITYP.EQ.2).AND.(LL.NE.RR))IFAIL=5
C
C---   EXIT BEI FEHLER
C
       IF(IFAIL.NE.0)RETURN
       IF(ITYP.EQ.3) THEN
          L=RR
          R=LL
          ITYP=0
          TRANS=.TRUE.
       ELSE
          L=LL
          R=RR
          TRANS=.FALSE.
       ENDIF
C
C---   FORMATART IN FORMAT SCHREIBEN
C
       IF (IFORM.EQ.0) THEN
          FORM='E'
       ELSE IF (IFORM.EQ.1) THEN
          FORM='F'
       ELSE
          FORM='G'
       ENDIF
       FORMPR(10:10)=FORM(1:1)
C
C      ANZAHL ZAHLEN PRO ZEILE BERECHNEN
C
       ANZDIG=6
       IF(IFORM.EQ.1)ANZDIG=NUMDIG(A,L,R,ITYP)
       ILANG=IANZ+ANZDIG+1
       IOFT=FORMW/ILANG
C
C---   LAENGE BZW. NACHKOMMAST. IN FORMAT SCHREIBEN
C
       WRITE(ZAHL2,'(I2)')IANZ
       FORMPR(14:15)=ZAHL2(1:2)
       WRITE(ZAHL2,'(I2)')IANZ+ANZDIG
       FORMPR(11:12)=ZAHL2(1:2)
       CALL ADV(2,4)
       WRITE(IAUS,9000)
C
C---   MATRIX DRUCKEN (GROSSE SCHLEIFE)
C
       DO 10 I=1,R,IOFT
C
C---       KOPFZEILE UND FORMATE
C
           FORMPR(2:4)='  1'
           IF(I+IOFT.GT.R)THEN
               IEND=R
               IOFT=R-I+1
               WRITE(ZAHL2,'(I2)')R-I+1
               FORMPR(7:8)=ZAHL2(1:2)
               IF(I.NE.1)THEN
                   CALL ADV(3,5)
                   WRITE(IAUS,8050)I,R
               ENDIF
           ELSE
               WRITE(ZAHL2,'(I2)')IOFT
               FORMPR(7:8)=ZAHL2(1:2)
               CALL ADV(3,5)
               WRITE(IAUS,8050)I,I+IOFT-1
               IEND=I+IOFT-1
           ENDIF
C
C---       BLOCK DRUCKEN
C
C---       NORMALE MATRIX
C
           IF(ITYP.EQ.0)THEN
               DO 11 J=1,L
                   CALL ADV(1,1)
                   IF(TRANS) THEN
                      WRITE(IAUS,FORMPR)(A(K,J),K=I,IEND)
                   ELSE
                      WRITE(IAUS,FORMPR)(A(J,K),K=I,IEND)
                   ENDIF
11             CONTINUE
           ENDIF
C
C---       DIAGONALMATRIX
C
           IF(ITYP.EQ.2)THEN
               CALL ADV(1,1)
               WRITE(IAUS,FORMPR)(A(K,K),K=I,IEND)
           ENDIF
C
C---   SYMMETRISCHE MATRIX
C
           IF(ITYP.EQ.1)THEN
C
C              NICHTSYMMETRISCHEN TEIL DRUCKEN
C
               DO 12 J=1,I-1
                   CALL ADV(1,1)
                   WRITE(IAUS,FORMPR)(A(J,K),K=I,IEND)
12             CONTINUE
C
C---   SYMMETRISCHEN TEIL DRUCKEN
C
               TAB=1
               IOFT2=IOFT
               DO 13 J=I,I+IOFT-1
                   CALL ADV(1,1)
                   WRITE(IAUS,FORMPR)(A(J,K),K=J,IEND)
                   TAB=TAB+ILANG
                   IOFT2=IOFT2-1
                   WRITE(ZAHL3,'(I3)')TAB
                   FORMPR(2:4)=ZAHL3(1:3)
                   WRITE(ZAHL2,'(I2)')IOFT2
                   FORMPR(7:8)=ZAHL2(1:2)
13             CONTINUE
           ENDIF
10     CONTINUE
       CALL ADV(2,2)
       WRITE(IAUS,9000)
       RETURN
C
C---   FORMATE
C
8050   FORMAT(1X/5X,'ROW: ',I4,' TO: ',I4/)
9000   FORMAT(/)
       END
      SUBROUTINE NORM(A,L,R,NM)
      IMPLICIT LOGICAL(A-Z)
C
C     ZWECK: BILDE DIE EUKLIDISCHE NORM NM DER MATRIX A
C
C     DIE PARAMETERUEBERPRUEFUNG FINDET IM AUFRUFPROGRAMM
C     STATT
C
      INTEGER L,R,I
      REAL  NM,A(*)
      NM=0.0
      DO 1 I=1,L*R
      NM=NM+A(I)*A(I)
1     CONTINUE
      NM=SQRT(NM)
      RETURN
      END
       INTEGER FUNCTION NUMDIG(A,L,R,ITYP)
       IMPLICIT LOGICAL (A-Z)
       INTEGER L,R,ITYP,J,I
       REAL  A(L,R),MAX
C
C      ZWECK:
C      =====
C      ES WIRD IN DER MATRIX A DAS GROESSTE ELEMENT GESUCHT
C      UND DIE FORMATLAENGE DES FORTRAN F- FORMATES BESTIMMT.
C      NUMDIG= 2 + IFIX(LG( ABS(MAX. ELEMENT)))
C
C      PARAMETER
C      =========
C
C      A(L,R)  - REAL ARRAY
C         A  WIRD VON DIESER FUNKTION UNTERSUCHT
C      L,R  - INTEGER
C         DIMENSION VON A
C      ITYP  - INTEGER
C       = 0  RECHTECKIGE MATRIX
C       = 1  SYMMETRISCHE MATRIX
C       = 2  DIAGONALMTRIX
C
C
       MAX=0.0
       IF(ITYP.EQ.0)THEN
           DO 10 J=1,R
               DO 10 I=1,L
                   IF(ABS(A(I,J)).GT.MAX)MAX=ABS(A(I,J))
10         CONTINUE
       ENDIF
       IF(ITYP.EQ.1) THEN
           DO 11 J=1,R
               DO 11 I=J,L
                   IF(ABS(A(I,J)).GT.MAX) MAX=ABS(A(I,J))
11         CONTINUE
       ENDIF
       IF(ITYP.EQ.2)THEN
           DO 12 I=1,L
               IF(ABS(A(I,I)).GT.MAX)MAX= ABS(A(I,I))
12         CONTINUE
       ENDIF
       IF(MAX.LT.1.0) MAX=1.0
       MAX=LOG10(MAX)
       NUMDIG=3 + MAX
       RETURN
       END
      SUBROUTINE PSINV(D,S,A,N,IR)
      IMPLICIT LOGICAL(A-Z)
C
      INTEGER N,IFAIL,IR,R1,I,J,K,IR1
      REAL S(N,N),D(N),A(N,N),SUM
C
      IR1= IR+1
      DO 100 I=1,N
         DO 100 J=I,N
            SUM=0.0D0
            DO 110 K= IR1,N
               SUM=SUM+S(I,K)*S(J,K)/D(K)
110         CONTINUE
            A(I,J)=SUM
            A(J,I)=SUM
100   CONTINUE
      END
      SUBROUTINE RDCODE(EOF)
      IMPLICIT LOGICAL(A-Z)
C
C     SUBROUTINE READS CODE
C
      LOGICAL EOF
      INTEGER I
C
      INTEGER LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2
      INTEGER LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC
      INTEGER SLINE,OPCODE,OPT1,OPT2,OPT3,EXTADR,FLINES
C
      INTEGER LLINE,MXLINE,FW,LDNI,LDNO,LDNC
      INTEGER MAXRAM,DATSET,MAXPW2,MINPW2
      REAL TOL,EPS
      LOGICAL TEXT
C
      COMMON /COMI/ LA,RA,LA1,LA2,RA1,RA2,LB,RB,LB1,LB2,RB1,RB2,
     & LC,RC,LC1,LC2,RC1,RC2,ADRA,ADRB,ADRC,SLINE,OPCODE,
     & OPT1,OPT2,OPT3,EXTADR,FLINES,MAXRAM,LDNI,LDNO,LLINE,MXLINE,
     & FW,LDNC,TEXT,DATSET,TOL,EPS,MAXPW2,MINPW2
C
C
      CHARACTER  INFILE*80,OFILE*80,PROGN*20,TXT*20
      DIMENSION TXT(7)
C
      COMMON /COMC/ INFILE,OFILE,PROGN,TXT
C
C
C     READ HEADER LINE
C
      READ(LDNC,8000,END=900)EXTADR,OPCODE,SLINE,FLINES,OPT1,OPT2,OPT3
      IF(EXTADR.LT.0) EXTADR= EXTADR+ MAXRAM
      IF(OPCODE.EQ.7) THEN
         DO 100 I= 1,FLINES
            READ(LDNC,8010) TXT(I)
100      CONTINUE
      ELSE
         IF(FLINES.GT.0)THEN
            READ(LDNC,8000)ADRA,LA,RA,LA1,LA2,RA1,RA2
            IF(ADRA.LT.0) ADRA= ADRA+ MAXRAM
         ENDIF
         IF(FLINES.GT.1)THEN
            READ(LDNC,8000)ADRB,LB,RB,LB1,LB2,RB1,RB2
            IF(ADRB.LT.0) ADRB= ADRB+ MAXRAM
         ENDIF
         IF(FLINES.GT.2)THEN
            READ(LDNC,8000)ADRC,LC,RC,LC1,LC2,RC1,RC2
            IF(ADRC.LT.0) ADRC= ADRC+ MAXRAM
         ENDIF
      ENDIF
      EOF= .FALSE.
      RETURN
C
900   EOF=.TRUE.
8000  FORMAT(I11,6(1X,I4))
8010  FORMAT(A)
      END
C
      SUBROUTINE RNORM(A,L,R,B)
      IMPLICIT LOGICAL(A-Z)
C
C     ZWECK: BILDE DIE ZEILENNORM VON A (MAX. ZEILENSUMME DER
C     BETRAEGE DER ZEILENELEMENTE VON A
C
      INTEGER L,R,I,J,K,K0
      REAL A(*),B,SUM
C
      B= 0.0D0
      K0=1
      DO 100 I=1,L
         SUM=0.0D0
         K=K0
         DO 200 J=1,R
            SUM=SUM+ABS(A(K))
            K=K+L
200      CONTINUE
         IF(SUM.GT.B) B= SUM
         K0=K0+1
100   CONTINUE
      END
      SUBROUTINE SPUR(A,L,R,S)
      IMPLICIT LOGICAL(A-Z)
C
C     ZWECK: BILDE DIE SPUR DER MATRIX A
C
C     PARAMETERUEBERPRUEFUNG FINDET IM AUFRUFENDEN PRO-
C     GRAMM STATT.
C
      INTEGER I,L,R
      REAL S,A(*)
      S=0.0
      DO 1 I=1,L*L,L+1
      S=S+A(I)
1     CONTINUE
      RETURN
      END
      SUBROUTINE SSUM(A,L,R,B)
      IMPLICIT LOGICAL(A-Z)
C
C     ZWECK BILDE DEN SPALTENSUMMENVEKTOR VON A UND SCHREIBE IHN
C     NACH B.
C
C     PARAMETER          A(L,R)   EINGABEMATRIX     REAL
C                        B(1,R)   AUSGABEVEKTOR     REAL
C                        L,R      DIM(A)            INTEGER
C
C     GENAUIGKEIT: EINFACHGENAUE ARITHMETIK
C
      INTEGER I,J,L,R,IK,IMAX
      REAL A(*),B(R)
C
      IK=1
      DO 10 I=1,R
            B(I)=0.0
            DO 10 J=1,L
                  B(I)=B(I)+A(IK)
                  IK=IK+1
10                CONTINUE
      RETURN
      END
      SUBROUTINE TRANS(A,L,R,B)
      IMPLICIT LOGICAL(A-Z)
C
C     ZWECK: BILDE DIE TRANSPONIERTE MATRIX VON A UND SPEICHERE SIE
C     IN B AB.
C
C     PARAMETER:     A(L,R)      EINGABEMATRIX          REAL
C                    L,R         DIM(A),DIM(B)          INTEGER
C                    B(R,L)      AUSGABEMATRIX          REAL
C
C     GENAUIGKEIT: EXAKT
C
      INTEGER R,L,IR,IJ,I,J
      REAL A(*),B(*)
C
      IR=0
      DO 10 I=1,L
            IJ=I-L
            DO 10 J=1,R
                  IJ=IJ+L
                  IR=IR+1
10                B(IR)=A(IJ)
      RETURN
      END
      REAL FUNCTION X02AAF(X)
C
      REAL X
      X02AAF=  1.776356839400E-15
      END
      REAL FUNCTION X02ABF(X)
C
      REAL X
      X02ABF= 3.131513062514-294
      END
      INTEGER FUNCTION X02BCF(X)
C
      REAL X
      X02BCF= 977
      END
      INTEGER FUNCTION X02BDF(X)
C
      REAL X
      X02BDF= -977
      END
      SUBROUTINE X03AAF(A,ISIZEA,B,ISIZEB,N,ISTEPA,ISTEPB,
     & C1,C2,D1,D2,SW,IFAIL)
C
      IMPLICIT LOGICAL(A-Z)
C
      INTEGER ISIZEA,ISIZEB,N,ISTEPA,ISTEPB,IFAIL
      LOGICAL SW
      REAL A(ISIZEA),B(ISIZEB),C1,C2,D1,D2
C
      INTEGER I,J,K
C
C
      D1=C1
      D2=C2
      J=1
      K=1
      DO 100 I=1,N
         D1=D1+ A(J)*B(K)
         J=J+ISTEPA
         K=K+ISTEPB
100   CONTINUE
      IFAIL=0
      END
      SUBROUTINE ZSUM(A,L,R,B)
      IMPLICIT LOGICAL(A-Z)
C
C     ZWECK: BILDE DEN ZEILENSUMMENVEKTOR VON A UND SCHREIBE
C     IHN NACH B
C
C     PARAMETER:     A(L,R)        EINGABEMATRIX       REAL
C                    B(L,1)        SUMMENVEKTOR        REAL
C                    L,R           DIM(A)              INTEGER
C
C     GENUIGKEIT: EINFACHGENAUE ARITHMETIK
C
      INTEGER I,J,IK,L,R
      REAL  A(*), B(L)
C
      DO 10 I=1,L
            IK=I
            B(I)=0.0
            DO 10 J=1,R
                  B(I)=B(I)+A(IK)
                  IK=IK+L
10                CONTINUE
      RETURN
      END
~eor
4. 2. 1. -1.
-1. 3. 7. 2.
2. 5. -3. 4.
6. 2. 5. 2.
3. 2. 5. 2.
/ENDMAT
4. 7. 2. 1.
7. 9. 12. 16.
2. 12. 27. 35.
1. 16. 25. 48.
/ENDMAT
4. 7. 2. 1.
9. 12. 16.
27. 35.
48.
/ENDMAT
4. 9. 27. 48.
/ENDMAT
~eor
~eoi
