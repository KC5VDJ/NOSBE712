/*
 * Class definitions for DtCyber utilities
 * (c) 2022 Joachim Siebold
 *
 * If this program does not reside in a subdirectory of the DtCyber
 * distribution, the environment variable DTCYBER must be specified to
 * point to the distribution main directory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */

var DtCyber;
if (process.env.DTCYBER) {
   DtCyber = require(process.env.DTCYBER.concat("/automation/DtCyber"));
} else {
   DtCyber = require("../../automation/DtCyber");
}

/*
 * Custom class to process mt and cp requests
*/
class myDtCyber extends DtCyber {

/*
 * constructor initializes system configuration data as object vars
*/

   constructor() {
      super();
/*
 *    EST-Ordinal, Channel, Equipment, Unit of tape drives
*/
      this.tapeUnits= [
         [20,13,0,0],
         [21,13,0,1],
         [22,13,0,2],
         [23,13,0,3],
      ];
/*
 *    Channel, Equipment of Card Punch
 */
      this.cardPunch=[12,6];
   }

/*
 * get MT CH,EQ,UN from EST-Ordinal
*/
   getMT(estOrdinal) {
      for (let i=0;i< this.tapeUnits.length;i++) {
         if(this.tapeUnits[i][0]== estOrdinal) {
            return(this.tapeUnits[i]);
         }
      }
      return([0,0,0]);
   }

/*
 * remove cards from card punch
*/
   removeCards() {
     
     var cmd=`rc ${this.cardPunch[0]},${this.cardPunch[1]}`;
        this.send(cmd);
        return this.expect([
      {re:/No cards have been punched/,       fn:new Error(`No cards have been punched`)},
      {re:/No card punch/,       fn:new Error(`No card punch`)},
      {re:/Failed to open/,       fn:new Error(`Failed to open device ${cmd}`)},
      {re:/Not enough or invalid parameters/, fn:new Error(`Not enough or invalid parameters: ${cmd}`)},
      {re:/Invalid/,                          fn:new Error(`Invalid: ${cmd}`)},
      {re:/Operator> /}, 'dtCyber'
    ]);
   }

/*
 * mount tape
*/
   mountTape(ring,estOrdinal,fileName) {
      var tape= this.getMT(estOrdinal);
      const cmd = `lt ${tape[1]},${tape[2]},${tape[3]},${(typeof ring !== "undefined" && ring === true) ? "w" : "r"},${fileName}`;

      return new Promise((resolve,reject) => {
         this.say(`mount ${fileName} on NTG${estOrdinal}`)
         .then(() => { if(tape[0]==0) reject('illegal EST-Ordinal') })
         .then(() => this.send(cmd))
         .then(() => this.expect([
           {re:/Failed to open/, fn:new Error(`Failed to open ${tape}`)},
           {re:/Not enough or invalid parameters/, fn:new Error(`Not enough or invalid parameters: ${cmd}`)},
           {re:/Invalid/,  fn:new Error(`Invalid: ${cmd}`)},
           {re:/not allocated/,  fn:new Error(`NTG${estOrdinal} not allocated`)},
           {re:/not unloaded/,  fn:new Error(`NTG${estOrdinal} not unloaded`)},
           {re:/Operator> /}
           ]))
         .then(() => this.send('show_tape'))
         .then(() => this.showMtStatus())
         .then(() => this.sleep(1000))
         .then(() => { resolve(); })
         .catch(err => { reject(err); });
     });
   }

/*
 * unmount tape
*/
   unMountTape(estOrdinal) {
      var tape= this.getMT(estOrdinal);
      const cmd = `ut ${tape[1]},${tape[2]},${tape[3]}`;
      return new Promise((resolve,reject) => {
         if(tape[0]==0) {
            reject('illegal EST-Ordinal');
         }
         this.say(`umount NTG${estOrdinal}`)
         .then(() => this.send(cmd))
         .then(() => this.expect([
           {re:/not loaded/,  fn:new Error(`NTG${estOrdinal} not loaded`)},
           {re:/not allocated/,  fn:new Error(`NTG${estOrdinal} not allocated`)},
           {re:/Not enough or invalid parameters/, fn:new Error(`Not enough or invalid parameters: ${cmd}`)},
           {re:/Invalid/,      fn:new Error(`Invalid: ${cmd}`)},
           {re:/Operator> /}
          ]))
         .then(() => this.send('show_tape'))
         .then(() => this.showMtStatus())
         .then(() => this.sleep(1000))
         .then(() => { resolve() })
          .catch(err => { reject(err) });
      });
   }

/*
 * show tape status
*/
   showMtStatus() {
      return new Promise((resolve,reject) => {
         let str="";
         let mgr=this.getStreamMgr('dtCyber');
         mgr.startConsumer(data => {
            console.log(data.toString('utf8'));
            resolve();
         });
      });
   }

/*
 * error function, prompt error and exit
 */
   error(err) {
      console.log(err.toString());
      process.stdout.write("Press ENTER to terminate...");
      process.stdin.on("data", data => {
        process.exit(1);
      });
      process.stdin.on("close", () => {
        process.exit(1);
      });
   }
}

module.exports = {
  myDtCyber,
}
